# QOF JSON Format Specification

## Overview

This document defines the generic JSON format for QOF (Quality and Outcomes Framework) specifications. QOF specifications are machine-readable documents that define the structure and rules for extracting and processing QOF data from patient records.

The JSON format is a structured representation of QOF specifications that break down the complex data requirements into four main logical sections:
1. **Selections** - Patient selection criteria
2. **Registers** - Population definitions  
3. **Extraction Fields** - Data elements to be extracted
4. **Indicators** - Clinical outcome measures and their calculation rules

## Root Structure

The root level of a QOF JSON document contains the following properties:

```json
{
  "name": "string",
  "selections": [ ... ],
  "registers": [ ... ],
  "extractionFields": [ ... ],
  "indicators": [ ... ]
}
```

### Java Implementation

The QOF document structure is implemented as the `QOFDocument` class located at:
`src/main/java/org/endeavourhealth/imapi/model/qof/QOFDocument.java`

**Class Structure:**
```java
public class QOFDocument {
  private String name;
  private List<Selection> selections = new ArrayList<>();
  private List<Register> registers = new ArrayList<>();
  private List<ExtractionField> extractionFields = new ArrayList<>();
  private List<Indicator> indicators = new ArrayList<>();
  
  // Getters and setters follow the fluent pattern
  public String getName() { ... }
  public QOFDocument setName(String name) { ... }
  public List<Selection> getSelections() { ... }
  public QOFDocument setSelections(List<Selection> selections) { ... }
  public List<Register> getRegisters() { ... }
  public QOFDocument setRegisters(List<Register> registers) { ... }
  public List<ExtractionField> getExtractionFields() { ... }
  public QOFDocument setExtractionFields(List<ExtractionField> extractionFields) { ... }
  public List<Indicator> getIndicators() { ... }
  public QOFDocument setIndicators(List<Indicator> indicators) { ... }
}
```

### Root Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `name` | string | Yes | Unique identifier for the QOF specification document (e.g., "Diabetes_v49.0") |
| `selections` | array | Yes | Array of selection criteria objects that define how patients are initially selected |
| `registers` | array | Yes | Array of register/population objects that define the populations for analysis |
| `extractionFields` | array | Yes | Array of extraction field objects that specify what data should be extracted |
| `indicators` | array | Yes | Array of indicator objects that define the output measures and their calculation rules |

---

## Selections

Selections define the initial screening criteria for patient inclusion. Each selection represents a set of rules that determine which patients should be considered for the QOF process.

### Selection Object Structure

```json
{
  "name": "string",
  "rules": [
    {
      "logic": "string",
      "ifTrue": "string",
      "ifFalse": "string",
      "description": "string"
    }
  ]
}
```

### Selection Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `name` | string | Yes | Descriptive name of the selection criteria (e.g., "GMS registration status") |
| `rules` | array | Yes | Array of rule objects that define the selection logic |

### Selection Rule Object

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `logic` | string | Yes | Logical expression describing the condition to evaluate (e.g., "(If REG_DAT ≠ Null AND If DEREG_DAT = Null) OR (If REG_DAT ≠ Null AND If DEREG_DAT > ACHV_DAT)") |
| `ifTrue` | string | Yes | Action to take if the logic condition is true (typically "Select" or "Reject") |
| `ifFalse` | string | Yes | Action to take if the logic condition is false (typically "Reject" or "Select") |
| `description` | string | Yes | Detailed human-readable explanation of the rule logic and actions |

#### Example Selection

```json
{
  "name": "GMS registration status",
  "rules": [
    {
      "logic": "(If REG_DAT ≠ Null AND If DEREG_DAT = Null) OR (If REG_DAT ≠ Null AND If DEREG_DAT > ACHV_DAT)",
      "ifTrue": "Select",
      "ifFalse": "Reject",
      "description": "Select patients who, on the achievement date, were registered for GMS..."
    }
  ]
}
```

---

## Registers (Populations)

Registers define the populations that will be analyzed for the indicators. Each register is built on top of selections and applies additional filtering rules.

### Register Object Structure

```json
{
  "name": "string",
  "description": "string",
  "base": "string",
  "rules": [
    {
      "rule": integer,
      "logic": "string",
      "ifTrue": "string",
      "ifFalse": "string",
      "description": "string"
    }
  ]
}
```

### Register Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `name` | string | Yes | Unique identifier for the register (e.g., "DM_REG") |
| `description` | string | Yes | Detailed description of the population definition (e.g., "Diabetes register: Patients aged at least 17 years old with an unresolved diabetes diagnosis.") |
| `base` | string | Yes | Name of the selection criteria upon which this register is based |
| `rules` | array | Yes | Array of rule objects that further refine the population |

### Register Rule Object

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `rule` | integer | Yes | Sequential rule number within the register |
| `logic` | string | Yes | Logical expression to evaluate |
| `ifTrue` | string | Yes | Action if true (e.g., "Select", "Reject", "Next rule") |
| `ifFalse` | string | Yes | Action if false (e.g., "Reject", "Select", "Next rule") |
| `description` | string | Yes | Human-readable explanation of the rule |

#### Register Rule Flow

Rules within a register are typically evaluated sequentially. The possible outcomes are:
- **"Select"** - Include the patient in the register population
- **"Reject"** - Exclude the patient from the register population
- **"Next rule"** - Pass the patient to the next rule in the sequence

#### Example Register

```json
{
  "name": "DM_REG",
  "description": "Diabetes register: Patients aged at least 17 years old with an unresolved diabetes diagnosis.",
  "base": "GMS registration status",
  "rules": [
    {
      "rule": 1,
      "logic": "If DMLAT_DAT ≠ Null AND If DMRES_DAT = Null",
      "ifTrue": "Next rule",
      "ifFalse": "Reject",
      "description": "Pass to the next rule all patients from the specified population who meet both of the criteria below..."
    },
    {
      "rule": 2,
      "logic": "If PAT_AGE < 17 years",
      "ifTrue": "Reject",
      "ifFalse": "Select",
      "description": "Reject patients passed to this rule who are aged under 17 years old on the achievement date..."
    }
  ]
}
```

---

## Extraction Fields

Extraction fields specify the data elements that should be extracted from patient records. Each field has specific logic determining how and when data is extracted.

### Extraction Field Object Structure

```json
{
  "field": integer,
  "name": "string",
  "cluster": "string",
  "logic": "string",
  "description": "string"
}
```

### Extraction Field Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `field` | integer | Yes | Sequential field number/identifier |
| `name` | string | Yes | Field name/code (e.g., "PAT_ID", "REG_DAT", "DM_DAT") |
| `cluster` | string | Yes | Cluster code grouping related fields, or "n/a" if field is ungrouped (e.g., "DM_COD", "CLINBP_COD") |
| `logic` | string | Yes | Extraction logic specifying which records to extract (e.g., "Latest <= ACHV_DAT", "Unconditional", "ALL <= ACHV_DAT") |
| `description` | string | Yes | Detailed explanation of what data the field represents |

### Extraction Logic Patterns

Common extraction logic patterns include:

- **Unconditional**: Extract the data without any temporal or value constraints
- **Latest <= DATE**: Extract the most recent record on or before a specified date
- **Earliest <= DATE**: Extract the first record on or before a specified date
- **ALL <= DATE**: Extract all records on or before a specified date
- **Date ranges**: Extract records within specific time windows (e.g., "Latest > DATE AND <= DATE")
- **Conditional extraction**: Extract records that meet specific value conditions

### Field Name Notation

Field names may include special notation:
- **{FIELD_NAME}** - Indicates an array of values
- **[FIELD_NAME]** - Indicates array elements corresponding to another field
- **FIELD_NAME** - Standard scalar field

#### Example Extraction Fields

```json
[
  {
    "field": 1,
    "name": "PAT_ID",
    "cluster": "n/a",
    "logic": "Unconditional",
    "description": "The patient's unique ID number for the practice in question."
  },
  {
    "field": 5,
    "name": "DM_DAT",
    "cluster": "DM_COD",
    "logic": "Earliest <= ACHV_DAT",
    "description": "Date of the first diabetes diagnosis up to and including the achievement date."
  },
  {
    "field": 12,
    "name": "{CLINBP_DAT}",
    "cluster": "CLINBP_COD",
    "logic": "ALL <= ACHV_DAT",
    "description": "All dates on which a blood pressure was recorded (excluding home/ambulatory), up to and including the achievement date."
  },
  {
    "field": 13,
    "name": "[CLINBPSYS_VAL]",
    "cluster": "CLINBP_COD",
    "logic": "Recorded on each {CLINBP_DAT}",
    "description": "The systolic blood pressure values associated with each date in the {CLINBP_DAT} array."
  }
]
```

---

## Indicators

Indicators define the clinical outcome measures that are calculated from the extracted data. Each indicator specifies a numerator and denominator through a series of sequential rules applied to the register population.

### Indicator Object Structure

```json
{
  "name": "string",
  "description": "string",
  "base": "string",
  "rules": [
    {
      "rule": integer,
      "logic": "string",
      "ifTrue": "string",
      "ifFalse": "string",
      "description": "string"
    }
  ]
}
```

### Indicator Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `name` | string | Yes | Unique indicator code (e.g., "DM006", "DM020", "DM033") |
| `description` | string | Yes | Clear description of what the indicator measures (e.g., "The percentage of patients with diabetes, on the register, with a diagnosis of nephropathy...") |
| `base` | string | Yes | Name of the register population this indicator is based on |
| `rules` | array | Yes | Array of rule objects that calculate the indicator |

### Indicator Rule Object

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `rule` | integer | Yes | Sequential rule number within the indicator |
| `logic` | string | Yes | Complex logical expression for evaluation |
| `ifTrue` | string | Yes | Action if condition is true ("Select", "Reject", or "Next rule") |
| `ifFalse` | string | Yes | Action if condition is false ("Select", "Reject", or "Next rule") |
| `description` | string | Yes | Detailed explanation of the rule's purpose and logic |

### Indicator Rule Flow

Rules are evaluated sequentially:
- **"Select"** - Include patient in the numerator (count towards achievement)
- **"Reject"** - Exclude patient from the numerator
- **"Next rule"** - Continue evaluating with the next rule

### Complex Logic in Indicators

Indicator rules often contain complex Boolean logic combining multiple conditions:
- Nested conditions with AND/OR operators
- Multiple date comparisons (e.g., "Latest > PPED – 12 months")
- Value comparisons (e.g., "If CLINBPSYSLAT_VAL <= 140")
- Complex branching with multiple paths

#### Example Indicator

```json
{
  "name": "DM006",
  "description": "The percentage of patients with diabetes, on the register, with a diagnosis of nephropathy (clinical proteinuria) or micro-albuminuria who are currently treated with an ACE-I (or ARBs).",
  "base": "DM_REG",
  "rules": [
    {
      "rule": 1,
      "logic": "If PRT_DAT = Null AND If MAL_DAT = Null",
      "ifTrue": "Reject",
      "ifFalse": "Next rule",
      "description": "Reject patients from the specified population who meet both of the criteria below: Have no record of a proteinuria code. Have no record of a microalbuminuria code. Pass all remaining patients to the next rule."
    },
    {
      "rule": 2,
      "logic": "If ACE_DAT > (PPED – 6 months) OR If AII_DAT > (PPED – 6 months)",
      "ifTrue": "Select",
      "ifFalse": "Next rule",
      "description": "Select patients passed to this rule who meet either of the criteria below: Have been treated with an ACE inhibitor in the 6 months leading up to and including the payment period end date. Have been treated with an ARB in the 6 months leading up to and including the payment period end date. Pass all remaining patients to the next rule."
    }
  ]
}
```

---

## Common Variables and Abbreviations

Variables and abbreviations commonly used in logic expressions:

| Variable | Description |
|----------|-------------|
| ACHV_DAT | Achievement date (the reference date for the QOF year) |
| PPED | Payment period end date |
| REG_DAT | Registration date |
| DEREG_DAT | Deregistration date |
| PAT_AGE | Patient age (typically in years) |
| <= | Less than or equal to |
| > | Greater than |
| ≠ | Not equal to |
| = | Equal to |
| Null | No data / missing value |

---

## Data Processing Flow

The typical flow of QOF data processing is:

1. **Selection** - Apply selection rules to identify candidate patients
2. **Register Population** - Further filter the selected patients using register rules to define the denominator
3. **Data Extraction** - Extract relevant data fields for each patient in the register
4. **Indicator Calculation** - Apply indicator rules to count patients in the numerator
5. **Outcome** - Calculate indicator performance as: Numerator ÷ Denominator × 100%

---

## Validation Rules

When working with QOF JSON specifications:

1. All required properties must be present
2. Sequential numbering (field numbers, rule numbers) should be consistent
3. Logic expressions should reference only fields that are included in the extractionFields array
4. Indicators should reference valid register names in the "base" property
5. Registers should reference valid selection names in the "base" property
6. Rule outcomes ("Select", "Reject", "Next rule") should form a logical flow leading to a terminal state

---

## Notes on Design

- The JSON structure provides a machine-readable format that preserves the logical structure of the specification document
- Complex clinical logic is expressed in natural language within the "logic" and "description" fields for readability
- The sequential rule structure (with "Next rule" outcomes) enables step-by-step evaluation and conditional processing
- Field notation (arrays and values) supports both scalar data and collections of data points
- The modular structure (selections → registers → indicators) allows reuse of components across multiple indicators