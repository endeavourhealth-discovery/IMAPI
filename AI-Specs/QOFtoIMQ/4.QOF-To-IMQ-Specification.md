# QOF to IMQuery Conversion Specification

## Introduction

This document specifies the conversion process from QOF JSON format to IMQuery language. The conversion program will consume QOF specifications in JSON format and produce equivalent queries expressed in IMQuery notation that can be executed against an IM (Information Manager) database.

---

## Overview

### Purpose
The conversion program transforms high-level QOF clinical specifications (which define patient populations, data extractions, and indicator calculations) into machine-executable IMQuery expressions that operate on semantic health information models.

### Scope
- **Input**: QOF JSON specification files conforming to the QOF-Specification.md format
- **Output**: IMQuery JSON files conforming to the IMQ-Specification.md format
- **Responsibility**: Mapping QOF logical structures to equivalent IMQuery query structures
- **Out of Scope**: Execution of queries, database operations, result calculation

### Key Principles
1. **Semantic Equivalence** - The generated IMQuery must express the same clinical logic as the source QOF specification
2. **Preservability** - Mapping should preserve all relevant metadata and descriptions
3. **Explicitness** - Conversion rules should be transparent and traceable
4. **Modularity** - Each QOF component (Selections, Registers, Indicators) converts independently

### Java Implementation References

The conversion process is implemented using the following Java classes:

**Input Classes (QOF Domain):**
- `QOFDocument` - Root container for QOF specifications
  - Located: `src/main/java/org/endeavourhealth/imapi/model/qof/QOFDocument.java`
  - Encapsulates: selections, registers, extractionFields, indicators

**Output Classes (IMQuery Domain):**
- `Query` - Root container for IMQuery expressions
  - Located: `src/main/java/org/endeavourhealth/imapi/model/imq/Query.java`
  - Encapsulates: query logic, prefixes, path navigation, filtering, and return specifications

The conversion implementation uses the fluent builder pattern provided by both classes to simplify programmatic construction of queries during transformation.

---

## Input Specification

### QOF JSON Structure
The input is a QOF document with the following top-level structure:

```json
{
  "name": "string",
  "selections": [ Selection ],
  "registers": [ Register ],
  "extractionFields": [ ExtractionField ],
  "indicators": [ Indicator ]
}
```

### QOF Components

#### Selection Object
```json
{
  "name": "string",
  "rules": [
    {
      "logic": "string",
      "ifTrue": "Select|Reject",
      "ifFalse": "Select|Reject",
      "description": "string"
    }
  ]
}
```

#### Register Object
```json
{
  "name": "string",
  "description": "string",
  "base": "string (Selection name)",
  "rules": [
    {
      "rule": integer,
      "logic": "string",
      "ifTrue": "Select|Reject|Next rule",
      "ifFalse": "Select|Reject|Next rule",
      "description": "string"
    }
  ]
}
```

#### Extraction Field Object
```json
{
  "field": integer,
  "name": "string",
  "cluster": "string",
  "logic": "string",
  "description": "string"
}
```

#### Indicator Object
```json
{
  "name": "string",
  "description": "string",
  "base": "string (Register name)",
  "rules": [
    {
      "rule": integer,
      "logic": "string",
      "ifTrue": "Select|Reject|Next rule",
      "ifFalse": "Select|Reject|Next rule",
      "description": "string"
    }
  ]
}
```

---

## Output Specification

### IMQuery Output Structure
The output is one or more IMQuery documents with the following structure:

```json
{
  "iri": "string (IRI for this query)",
  "name": "string",
  "description": "string",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "isCohort": { CohortReference } | null,
  "rule": [ Rule ],
  "return": { ReturnSpecification },
  "variable": "string"
}
```

### Output Properties

Each converted query must include:
- **iri**: A unique IRI identifier (generated from the QOF component)
- **name**: Human-readable name from the QOF source
- **description**: Description from the QOF source
- **typeOf**: Always `http://endhealth.info/im#Patient` for patient-based queries
- **isCohort**: Reference to prerequisite cohort (if query is based on another)
- **rule**: Array of rules converted from QOF logic
- **return**: Standard return specification for queries
- **variable**: Named variable for result reference

---

## Conversion Mapping

### 1. Selections → IMQuery Queries

#### Mapping Strategy
Each QOF Selection becomes an IMQuery cohort query that:
1. Operates on Patient type
2. Converts selection rules into IMQuery rule structures
3. Becomes referenceable as a `isCohort` for downstream queries

#### Rule Conversion

**QOF Selection Rule:**
```json
{
  "logic": "(If REG_DAT ≠ Null AND If DEREG_DAT = Null) OR (If REG_DAT ≠ Null AND If DEREG_DAT > ACHV_DAT)",
  "ifTrue": "Select",
  "ifFalse": "Reject",
  "description": "Select patients who, on the achievement date, were registered for GMS..."
}
```

**Conversion Process:**
1. Parse the logic expression to identify field references
2. Map QOF field references to IMQuery property IRIs
3. Identify temporal relationships (e.g., comparisons to ACHV_DAT)
4. Create IMQuery WHERE conditions for field validation
5. Map ifTrue/ifFalse outcomes to IMQuery actions

**Expected IMQuery Output:**
```json
{
  "iri": "http://endhealth.info/qof#[selection-id]",
  "name": "GMS registration status",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "rule": [
    {
      "ifTrue": "SELECT",
      "ifFalse": "REJECT",
      "description": "Select patients who, on the achievement date, were registered for GMS...",
      "where": {
        "or": [
          {
            "and": [
              {
                "iri": "http://endhealth.info/im#gmsRegistrationDate",
                "operator": "!=",
                "value": null
              },
              {
                "iri": "http://endhealth.info/im#gmsDeregistrationDate",
                "operator": "=",
                "value": null
              }
            ]
          },
          {
            "and": [
              {
                "iri": "http://endhealth.info/im#gmsRegistrationDate",
                "operator": "!=",
                "value": null
              },
              {
                "iri": "http://endhealth.info/im#gmsDeregistrationDate",
                "operator": ">",
                "relativeTo": {
                  "parameter": "$achievementDate"
                }
              }
            ]
          }
        ]
      }
    }
  ]
}
```

---

### 2. Registers → IMQuery Queries with Cohort References

#### Mapping Strategy
Each QOF Register becomes an IMQuery query that:
1. References its base Selection as a `isCohort`
2. Converts register rules into a sequence of IMQuery rules
3. Becomes referenceable for Indicator queries

#### Register Conversion

**QOF Register:**
```json
{
  "name": "DM_REG",
  "description": "Diabetes register: Patients aged at least 17 years old with an unresolved diabetes diagnosis.",
  "base": "GMS registration status",
  "rules": [
    {
      "rule": 1,
      "logic": "If DMLAT_DAT ≠ Null AND If DMRES_DAT = Null",
      "ifTrue": "Next rule",
      "ifFalse": "Reject",
      "description": "Pass to the next rule all patients from the specified population..."
    },
    {
      "rule": 2,
      "logic": "If PAT_AGE < 17 years",
      "ifTrue": "Reject",
      "ifFalse": "Select",
      "description": "Reject patients passed to this rule who are aged under 17 years old..."
    }
  ]
}
```

**Conversion Process:**
1. Create IMQuery query with base Selection as `isCohort`
2. For each sequential rule:
   - Parse rule logic for field references
   - Map "Next rule" to "NEXT" action
   - Map "Select" to "SELECT" action
   - Map "Reject" to "REJECT" action
3. Handle age calculations using function specifications
4. Preserve rule ordering and sequencing

**Expected IMQuery Output:**
```json
{
  "iri": "http://endhealth.info/qof#DM_REG",
  "name": "DM_REG",
  "description": "Diabetes register: Patients aged at least 17 years old with an unresolved diabetes diagnosis.",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "isCohort": {
    "name": "GMS registration status",
    "iri": "http://endhealth.info/qof#[gms-selection-id]"
  },
  "rule": [
    {
      "ifTrue": "NEXT",
      "ifFalse": "REJECT",
      "description": "Pass to the next rule all patients from the specified population...",
      "and": [
        {
          "where": {
            "iri": "http://endhealth.info/im#latestDiabetesDiagnosisDate",
            "operator": "!=",
            "value": null
          }
        },
        {
          "where": {
            "iri": "http://endhealth.info/im#latestDiabetesResolvedDate",
            "operator": "=",
            "value": null
          }
        }
      ]
    },
    {
      "ifTrue": "REJECT",
      "ifFalse": "SELECT",
      "description": "Reject patients passed to this rule who are aged under 17 years old...",
      "where": {
        "iri": "http://endhealth.info/im#age",
        "operator": "<",
        "value": "17",
        "relativeTo": {
          "parameter": "$searchDate"
        },
        "units": {
          "name": "Years",
          "iri": "http://endhealth.info/im#Years"
        }
      }
    }
  ]
}
```

---

### 3. Extraction Fields → Data Model Configuration

#### Mapping Strategy
Extraction fields define what data to extract. These typically don't convert to standalone queries, but rather:
1. Inform the structure of return specifications in downstream queries
2. Define variable mappings for field references in logic expressions
3. Create a data dictionary for the conversion process

#### Extraction Field Processing

**QOF Extraction Field:**
```json
{
  "field": 5,
  "name": "DM_DAT",
  "cluster": "DM_COD",
  "logic": "Earliest <= ACHV_DAT",
  "description": "Date of the first diabetes diagnosis up to and including the achievement date."
}
```

**Processing:**
1. Create mapping: QOF field name → IMQuery property IRI
2. Parse extraction logic to determine temporal patterns:
   - "Earliest <= ACHV_DAT" → `operator: "<=", relativeTo: "$achievementDate", orderBy: "ascending", limit: 1`
   - "Latest <= ACHV_DAT" → `operator: "<=", relativeTo: "$achievementDate", orderBy: "descending", limit: 1`
   - "ALL <= ACHV_DAT" → `operator: "<=", relativeTo: "$achievementDate"`
3. Build data dictionary entry for reference in logic expressions

**Field Mapping Dictionary Example:**
```
DM_DAT → {
  "iri": "http://endhealth.info/im#diabetesDiagnosisDate",
  "logic": "Earliest <= ACHV_DAT",
  "temporalPattern": {
    "operator": "<=",
    "relativeTo": "$achievementDate",
    "orderBy": "ascending",
    "limit": 1
  },
  "description": "Date of the first diabetes diagnosis..."
}
```

---

### 4. Indicators → Complex IMQuery Queries

#### Mapping Strategy
Each QOF Indicator becomes an IMQuery query that:
1. References its base Register as a `isCohort`
2. Implements a multi-rule evaluation structure
3. Uses SELECT for numerator inclusion, REJECT for exclusion

#### Indicator Conversion

**QOF Indicator:**
```json
{
  "name": "DM006",
  "description": "The percentage of patients with diabetes, on the register, with a diagnosis of nephropathy...",
  "base": "DM_REG",
  "rules": [
    {
      "rule": 1,
      "logic": "If PRT_DAT = Null AND If MAL_DAT = Null",
      "ifTrue": "Reject",
      "ifFalse": "Next rule",
      "description": "Reject patients from the specified population who meet both of the criteria below..."
    },
    {
      "rule": 2,
      "logic": "If ACE_DAT > (PPED – 6 months) OR If AII_DAT > (PPED – 6 months)",
      "ifTrue": "Select",
      "ifFalse": "Next rule",
      "description": "Select patients passed to this rule who meet either of the criteria below..."
    }
  ]
}
```

**Conversion Process:**
1. Create IMQuery query referencing base Register as `isCohort`
2. For each rule:
   - Parse complex logic with date arithmetic (e.g., "PPED – 6 months")
   - Handle OR conditions between multiple field checks
   - Convert date range calculations to relative date specifications
   - Map rules into sequential IMQuery rule array
3. Each rule becomes a separate entry in the `rule` array
4. All rules evaluate sequentially; first matching rule determines outcome

**Expected IMQuery Output:**
```json
{
  "iri": "http://endhealth.info/qof#DM006",
  "name": "DM006",
  "description": "The percentage of patients with diabetes, on the register, with a diagnosis of nephropathy...",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "isCohort": {
    "name": "DM_REG",
    "iri": "http://endhealth.info/qof#DM_REG"
  },
  "rule": [
    {
      "ifTrue": "REJECT",
      "ifFalse": "NEXT",
      "description": "Reject patients from the specified population who meet both of the criteria below...",
      "and": [
        {
          "where": {
            "iri": "http://endhealth.info/im#proteinuriaDiagnosisDate",
            "operator": "=",
            "value": null
          }
        },
        {
          "where": {
            "iri": "http://endhealth.info/im#microalbuminuriaDiagnosisDate",
            "operator": "=",
            "value": null
          }
        }
      ]
    },
    {
      "ifTrue": "SELECT",
      "ifFalse": "NEXT",
      "description": "Select patients passed to this rule who meet either of the criteria below...",
      "or": [
        {
          "where": {
            "iri": "http://endhealth.info/im#aceInhibitorDate",
            "operator": ">",
            "relativeTo": {
              "parameter": "$paymentPeriodEnd",
              "offset": -6,
              "unit": "months"
            }
          }
        },
        {
          "where": {
            "iri": "http://endhealth.info/im#arbDate",
            "operator": ">",
            "relativeTo": {
              "parameter": "$paymentPeriodEnd",
              "offset": -6,
              "unit": "months"
            }
          }
        }
      ]
    }
  ]
}
```

---

## Logic Expression Parsing

### Parsing Strategy

QOF logic expressions use natural language patterns that must be parsed into structured conditions. The parser must identify:
1. **Field References** - Identifiers like `REG_DAT`, `DEREG_DAT`, `PAT_AGE`
2. **Operators** - Comparison operators: `=`, `≠`, `<`, `<=`, `>`, `>=`
3. **Logical Connectors** - AND, OR operators
4. **Temporal References** - `ACHV_DAT`, `PPED`, date arithmetic
5. **Null Checks** - Explicit `Null` comparisons
6. **Grouped Expressions** - Parenthesized conditions

### Parsing Patterns

#### Pattern 1: Simple Null Check
```
Input:  "If REG_DAT ≠ Null"
Output: {
  "where": {
    "iri": "http://endhealth.info/im#registrationDate",
    "operator": "!=",
    "value": null
  }
}
```

#### Pattern 2: Date Comparison
```
Input:  "If REG_DAT <= ACHV_DAT"
Output: {
  "where": {
    "iri": "http://endhealth.info/im#registrationDate",
    "operator": "<=",
    "relativeTo": {
      "parameter": "$achievementDate"
    }
  }
}
```

#### Pattern 3: Age Comparison
```
Input:  "If PAT_AGE < 17 years"
Output: {
  "where": {
    "iri": "http://endhealth.info/im#age",
    "operator": "<",
    "value": "17",
    "units": {
      "name": "Years",
      "iri": "http://endhealth.info/im#Years"
    }
  }
}
```

#### Pattern 4: Date Arithmetic
```
Input:  "If ACE_DAT > (PPED – 6 months)"
Output: {
  "where": {
    "iri": "http://endhealth.info/im#aceInhibitorDate",
    "operator": ">",
    "relativeTo": {
      "parameter": "$paymentPeriodEnd",
      "offset": -6,
      "unit": "months"
    }
  }
}
```

#### Pattern 5: Compound AND Condition
```
Input:  "(If REG_DAT ≠ Null AND If DEREG_DAT = Null)"
Output: {
  "and": [
    {
      "where": {
        "iri": "http://endhealth.info/im#registrationDate",
        "operator": "!=",
        "value": null
      }
    },
    {
      "where": {
        "iri": "http://endhealth.info/im#deregistrationDate",
        "operator": "=",
        "value": null
      }
    }
  ]
}
```

#### Pattern 6: Compound OR Condition
```
Input:  "(If REG_DAT ≠ Null AND If DEREG_DAT = Null) OR (If REG_DAT ≠ Null AND If DEREG_DAT > ACHV_DAT)"
Output: {
  "or": [
    {
      "and": [ ... ]
    },
    {
      "and": [ ... ]
    }
  ]
}
```

---

## Field Mapping Dictionary

### Purpose
A centralized mapping from QOF field names to IMQuery IRIs and their properties.

### Required Mappings

| QOF Field | IMQuery IRI | Type | Temporal Logic |
|-----------|------------|------|-----------------|
| REG_DAT | http://endhealth.info/im#registrationDate | Date | Latest <= ACHV_DAT |
| DEREG_DAT | http://endhealth.info/im#deregistrationDate | Date | Earliest > REG_DAT |
| PAT_AGE | http://endhealth.info/im#age | Integer | Computed at ACHV_DAT |
| DMLAT_DAT | http://endhealth.info/im#latestDiabetesDiagnosisDate | Date | Latest <= ACHV_DAT |
| DMRES_DAT | http://endhealth.info/im#latestDiabetesResolvedDate | Date | Latest > DMLAT_DAT |
| CLINBP_DAT | http://endhealth.info/im#clinicalBloodPressureDate | Date[] | ALL <= ACHV_DAT |
| CLINBPSYS_VAL | http://endhealth.info/im#clinicalBloodPressureSystolic | Integer | Per CLINBP_DAT |
| ACE_DAT | http://endhealth.info/im#aceInhibitorDate | Date | Latest <= ACHV_DAT |
| AII_DAT | http://endhealth.info/im#arbDate | Date | Latest <= ACHV_DAT |

### Mapping Features
- Maps between natural field names and semantic IRIs
- Specifies array vs. scalar types
- Defines default temporal patterns
- Extensible for additional fields

---

## IRI Generation Strategy

### IRI Namespace
All generated IRIs use the namespace: `http://endhealth.info/qof#`

### IRI Construction

#### For Selections
```
http://endhealth.info/qof#[selection-name-slugified]
Example: http://endhealth.info/qof#gms-registration-status
```

#### For Registers
```
http://endhealth.info/qof#[register-name]
Example: http://endhealth.info/qof#DM_REG
```

#### For Indicators
```
http://endhealth.info/qof#[indicator-name]
Example: http://endhealth.info/qof#DM006
```

### Slug Generation Rules
- Convert to lowercase
- Replace spaces with hyphens
- Remove special characters except hyphens
- Remove consecutive hyphens

---

## Output Organization

### Single vs. Multiple Output Files

#### Option 1: Single Output File
All converted queries in one file:
```
[
  { Query 1 (Selection) },
  { Query 2 (Selection) },
  { Query 3 (Register) },
  { Query 4 (Register) },
  { Query 5 (Indicator) },
  ...
]
```

#### Option 2: Organized Output Structure
```
{
  "metadata": {
    "source": "QOF-Diabetes.json",
    "conversionDate": "2024-01-15T10:30:00Z",
    "conversionVersion": "1.0"
  },
  "selections": [
    { Selection Query 1 },
    { Selection Query 2 }
  ],
  "registers": [
    { Register Query 1 },
    { Register Query 2 }
  ],
  "indicators": [
    { Indicator Query 1 },
    { Indicator Query 2 }
  ]
}
```

#### Recommended Approach
Use Option 2 (organized structure) for:
- Better organization and traceability
- Easier validation of each component type
- Clear separation of concerns
- Enhanced metadata tracking

---

## Validation Requirements

### Pre-Conversion Validation
Before conversion, the program should validate:

1. **QOF JSON Structure**
   - All required root properties present
   - Each Selections/Registers/Indicators has required fields
   - Rule objects have required properties

2. **Reference Integrity**
   - Each Register's `base` references an existing Selection
   - Each Indicator's `base` references an existing Register
   - No circular dependencies

3. **Field References**
   - All fields mentioned in logic exist in extractionFields
   - Field names are consistent (e.g., DMLAT_DAT is used consistently)

### Post-Conversion Validation
After conversion, the program should validate:

1. **IMQuery Structure**
   - All generated queries conform to IMQ-Specification.md
   - Required properties are present
   - IRIs are properly formatted

2. **Semantic Correctness**
   - Each converted rule contains valid WHERE clauses or isCohort references
   - Actions (SELECT/REJECT/NEXT) are valid for context
   - Cohort references point to existing queries

3. **Completeness**
   - All source QOF components have corresponding IMQuery queries
   - No data loss during conversion
   - All descriptions and metadata preserved

---

## Error Handling

### Error Categories

#### Parse Errors
- Unrecognized logic expression patterns
- Invalid field references
- Malformed date arithmetic

**Handling**: Generate detailed error message with line number, field name, and suggestion

#### Mapping Errors
- No IRI mapping for QOF field
- Invalid operator in expression
- Unknown temporal reference

**Handling**: Log warning, provide fallback mapping or generic IRI, continue conversion

#### Structural Errors
- Missing required QOF properties
- Broken references between components
- Invalid rule sequences

**Handling**: Fail fast with clear error message indicating location and remediation

#### Conversion Errors
- Unsupported logic pattern
- Complex nested conditions
- Ambiguous semantics

**Handling**: Generate partial conversion with annotations, log warnings, provide context for manual review

---

## Data Transformation Examples

### Example 1: Selection Conversion

**Input (QOF Diabetes Selection):**
```json
{
  "name": "GMS registration status",
  "rules": [
    {
      "logic": "(If REG_DAT ≠ Null AND If DEREG_DAT = Null) OR (If REG_DAT ≠ Null AND If DEREG_DAT > ACHV_DAT)",
      "ifTrue": "Select",
      "ifFalse": "Reject",
      "description": "Select patients who, on the achievement date, were registered for GMS..."
    }
  ]
}
```

**Output (IMQuery):**
```json
{
  "iri": "http://endhealth.info/qof#gms-registration-status",
  "name": "GMS registration status",
  "description": "Select patients who, on the achievement date, were registered for GMS...",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "rule": [
    {
      "ifTrue": "SELECT",
      "ifFalse": "REJECT",
      "where": {
        "or": [
          {
            "and": [
              {
                "iri": "http://endhealth.info/im#registrationDate",
                "operator": "!=",
                "value": null
              },
              {
                "iri": "http://endhealth.info/im#deregistrationDate",
                "operator": "=",
                "value": null
              }
            ]
          },
          {
            "and": [
              {
                "iri": "http://endhealth.info/im#registrationDate",
                "operator": "!=",
                "value": null
              },
              {
                "iri": "http://endhealth.info/im#deregistrationDate",
                "operator": ">",
                "relativeTo": {
                  "parameter": "$achievementDate"
                }
              }
            ]
          }
        ]
      }
    }
  ]
}
```

### Example 2: Register with Cohort Reference

**Input (QOF Diabetes Register):**
```json
{
  "name": "DM_REG",
  "description": "Diabetes register: Patients aged at least 17 years old with an unresolved diabetes diagnosis.",
  "base": "GMS registration status",
  "rules": [
    {
      "rule": 1,
      "logic": "If DMLAT_DAT ≠ Null AND If DMRES_DAT = Null",
      "ifTrue": "Next rule",
      "ifFalse": "Reject",
      "description": "Pass to the next rule all patients..."
    },
    {
      "rule": 2,
      "logic": "If PAT_AGE < 17 years",
      "ifTrue": "Reject",
      "ifFalse": "Select",
      "description": "Reject patients passed to this rule who are aged under 17 years old..."
    }
  ]
}
```

**Output (IMQuery with cohort reference):**
```json
{
  "iri": "http://endhealth.info/qof#DM_REG",
  "name": "DM_REG",
  "description": "Diabetes register: Patients aged at least 17 years old with an unresolved diabetes diagnosis.",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "isCohort": {
    "name": "GMS registration status",
    "iri": "http://endhealth.info/qof#gms-registration-status"
  },
  "rule": [
    {
      "ifTrue": "NEXT",
      "ifFalse": "REJECT",
      "description": "Pass to the next rule all patients...",
      "and": [
        {
          "iri": "http://endhealth.info/im#latestDiabetesDiagnosisDate",
          "operator": "!=",
          "value": null
        },
        {
          "iri": "http://endhealth.info/im#latestDiabetesResolvedDate",
          "operator": "=",
          "value": null
        }
      ]
    },
    {
      "ifTrue": "REJECT",
      "ifFalse": "SELECT",
      "description": "Reject patients passed to this rule who are aged under 17 years old...",
      "where": {
        "iri": "http://endhealth.info/im#age",
        "operator": "<",
        "value": "17",
        "relativeTo": {
          "parameter": "$searchDate"
        },
        "units": {
          "name": "Years",
          "iri": "http://endhealth.info/im#Years"
        }
      }
    }
  ]
}
```

### Example 3: Indicator with Complex Logic

**Input (QOF Indicator):**
```json
{
  "name": "DM006",
  "description": "The percentage of patients with diabetes, on the register, with a diagnosis of nephropathy...",
  "base": "DM_REG",
  "rules": [
    {
      "rule": 1,
      "logic": "If PRT_DAT = Null AND If MAL_DAT = Null",
      "ifTrue": "Reject",
      "ifFalse": "Next rule",
      "description": "Reject patients from the specified population..."
    },
    {
      "rule": 2,
      "logic": "If ACE_DAT > (PPED – 6 months) OR If AII_DAT > (PPED – 6 months)",
      "ifTrue": "Select",
      "ifFalse": "Next rule",
      "description": "Select patients passed to this rule who meet either of the criteria..."
    }
  ]
}
```

**Output (IMQuery with complex rules):**
```json
{
  "iri": "http://endhealth.info/qof#DM006",
  "name": "DM006",
  "description": "The percentage of patients with diabetes, on the register, with a diagnosis of nephropathy...",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "isCohort": {
    "name": "DM_REG",
    "iri": "http://endhealth.info/qof#DM_REG"
  },
  "rule": [
    {
      "ifTrue": "REJECT",
      "ifFalse": "NEXT",
      "description": "Reject patients from the specified population...",
      "and": [
        {
          "iri": "http://endhealth.info/im#proteinuriaDiagnosisDate",
          "operator": "=",
          "value": null
        },
        {
          "iri": "http://endhealth.info/im#microalbuminuriaDiagnosisDate",
          "operator": "=",
          "value": null
        }
      ]
    },
    {
      "ifTrue": "SELECT",
      "ifFalse": "NEXT",
      "description": "Select patients passed to this rule who meet either of the criteria...",
      "or": [
        {
          "iri": "http://endhealth.info/im#aceInhibitorDate",
          "operator": ">",
          "relativeTo": {
            "parameter": "$paymentPeriodEnd",
            "offset": -6,
            "unit": "months"
          }
        },
        {
          "iri": "http://endhealth.info/im#arbDate",
          "operator": ">",
          "relativeTo": {
            "parameter": "$paymentPeriodEnd",
            "offset": -6,
            "unit": "months"
          }
        }
      ]
    }
  ]
}
```

---

## Processing Architecture

### Component Responsibilities

#### 1. Input Loader
- Read QOF JSON file
- Validate JSON structure
- Parse into internal representations

#### 2. Validator
- Verify QOF structure and integrity
- Check reference consistency
- Validate field references
- Generate validation report

#### 3. Field Mapper
- Load field mapping dictionary
- Map QOF field names to IRIs
- Identify missing mappings
- Generate mapping warnings

#### 4. Logic Parser
- Parse QOF logic expressions
- Identify operators, fields, temporal references
- Build expression trees
- Handle parsing errors

#### 5. Converter
- Convert Selections to IMQueries
- Convert Registers with cohort references
- Convert Indicators with complex rules
- Maintain referential integrity

#### 6. Output Generator
- Serialize IMQuery objects to JSON
- Apply formatting/indentation
- Write to output file(s)
- Generate conversion report

#### 7. Error Handler
- Collect and categorize errors
- Generate detailed error messages
- Provide remediation suggestions
- Create error report

### Processing Flow

```
QOF JSON File
    ↓
Input Loader
    ↓
Validator (pre-conversion checks)
    ↓
Field Mapper (build mappings)
    ↓
Logic Parser (parse all logic expressions)
    ↓
Converter:
  ├→ Convert Selections
  ├→ Convert Registers (with cohort refs)
  └→ Convert Indicators (with complex rules)
    ↓
Output Generator
    ↓
Validator (post-conversion checks)
    ↓
Error Handler (collect/report issues)
    ↓
IMQuery Output File(s) + Report
```

---

## Special Handling Cases

### Case 1: Array Fields
QOF fields with array notation `{FIELD}` and `[FIELD]`:

**QOF Input:**
```json
{
  "field": 12,
  "name": "{CLINBP_DAT}",
  "logic": "ALL <= ACHV_DAT"
},
{
  "field": 13,
  "name": "[CLINBPSYS_VAL]",
  "logic": "Recorded on each {CLINBP_DAT}"
}
```

**Conversion Approach:**
- `{FIELD}` indicates array return, map to array property in IMQuery
- `[FIELD]` indicates parallel array member, create path-based access
- Generate path specifications for traversal

### Case 2: Cluster References
Fields grouped by cluster code:

**QOF Input:**
```json
{
  "name": "DM_DAT",
  "cluster": "DM_COD"
},
{
  "name": "DMLAT_DAT",
  "cluster": "DM_COD"
}
```

**Conversion Approach:**
- Group fields by cluster
- Use cluster code to identify related concept sets
- Map cluster to SNOMED concept set IRIs

### Case 3: Temporal Arithmetic
Complex date calculations:

**QOF Input:**
```
"If DMRES_DAT > DMLAT_DAT AND <= ACHV_DAT"
"If ACE_DAT > (PPED – 6 months)"
"If BPREAD_DAT >= (PPED – 12 months) AND < PPED"
```

**Conversion Approach:**
- Parse date arithmetic expressions
- Generate `relativeTo` with offsets
- Support multiple temporal constraints in single condition

### Case 4: Nested Conditions
Complex boolean expressions with multiple levels:

**QOF Input:**
```
"((A AND B) OR (C AND D)) AND ((E OR F) AND G)"
```

**Conversion Approach:**
- Build expression tree
- Recursively convert nested conditions
- Maintain operator precedence
- Flatten where possible

---

## Configuration and Extensibility

### Configuration File (Optional)
A YAML/JSON config file could specify:

```json
{
  "fieldMappings": "path/to/field-mappings.json",
  "outputFormat": "organized",
  "iriNamespace": "http://endhealth.info/qof#",
  "temporalParameters": {
    "achievementDate": "$achievementDate",
    "paymentPeriodEnd": "$paymentPeriodEnd"
  },
  "errorHandling": "strict",
  "generateReport": true
}
```

### Extensibility Points
1. Custom field mapping files
2. Pluggable logic expression parsers
3. Custom IRI generation strategies
4. Alternative output formats (XML, SQL, etc.)
5. Custom validation rules

---

## Reporting and Artifacts

### Conversion Report
The program should generate a report including:

1. **Summary**
   - Source file
   - Conversion date/time
   - Components processed
   - Success/failure status

2. **Conversion Statistics**
   - Total Selections: N
   - Total Registers: N
   - Total Indicators: N
   - Total Queries Generated: N

3. **Mappings Used**
   - Fields mapped to IRIs
   - Custom mappings applied

4. **Warnings and Issues**
   - Field mapping gaps
   - Unparseable logic expressions
   - Reference errors
   - Suggestions

5. **Output Details**
   - Output file path(s)
   - IMQuery schema compliance
   - Generated IRIs

### Artifacts
- Primary: IMQuery JSON output file(s)
- Secondary: Conversion report (text/HTML)
- Optional: Field mapping report
- Optional: Validation report

---

## Limitations and Future Enhancements

### Known Limitations
1. **Complex Nesting** - Very deeply nested boolean expressions may not parse correctly
2. **Natural Language** - Non-standard phrasing in logic expressions may not parse
3. **Field Gaps** - Unmapped QOF fields require manual configuration
4. **Semantic Precision** - Some clinical nuances may be lost in translation

### Future Enhancement Opportunities
1. Support for SNOMED concept set mapping
2. Automated field mapping discovery
3. Query optimization and simplification
4. SQL code generation from IMQuery output
5. Bidirectional conversion (IMQuery → QOF)
6. Interactive mapping tool for field disambiguation
7. Support for other specification formats

---

## Conclusion

This specification provides a comprehensive blueprint for implementing the QOF to IMQuery conversion program. The conversion process involves:

1. **Parsing** QOF JSON structures
2. **Mapping** QOF concepts to IMQuery semantics
3. **Converting** logical rules into query expressions
4. **Generating** valid IMQuery output
5. **Validating** structural and semantic correctness
6. **Reporting** on the conversion process

By following this specification, the implementation should produce correct, semantically equivalent IMQuery expressions that capture the intent and logic of the original QOF specifications.