# IMQ to SQL Conversion Plan

## Executive Summary

This document outlines the strategic approach for converting Information Model Query (IMQ) specifications into executable SQL statements against the Compass 2.3.0 database. The conversion process leverages a configurable mapping file that bridges semantic health data model concepts with relational database schema entities, enabling automatic SQL generation without manual coding.

**Target Database**: Discovery Compass 2.3.0  
**Primary Input**: IMQ JSON structures  
**Primary Output**: Executable SQL SELECT statements  
**Configuration**: YAML/JSON mapping file defining IMQ-to-Compass entity/property translations  

---

## Table of Contents

1. [Conversion Architecture](#conversion-architecture)
2. [Phase Overview](#phase-overview)
3. [IMQ to Compass Entity Mapping](#imq-to-compass-entity-mapping)
4. [Conversion Pipeline](#conversion-pipeline)
5. [Mapping Configuration File](#mapping-configuration-file)
6. [Core Conversion Rules](#core-conversion-rules)
7. [Advanced Patterns](#advanced-patterns)
8. [Implementation Phases](#implementation-phases)
9. [Edge Cases and Special Handling](#edge-cases-and-special-handling)

---

## Conversion Architecture

### High-Level Flow

```
IMQ (JSON)
    ↓
[IMQ Parser]
    ↓
[Entity/Property Resolver] (uses Mapping File)
    ↓
[Condition Translator] (WHERE clauses)
    ↓
[Path Navigator] (JOINs)
    ↓
[SQL Generator]
    ↓
[Query Optimizer]
    ↓
SQL (executable)
```

### Key Design Principles

1. **Configurable Mapping**: All IMQ-to-Compass translations defined externally, not hardcoded
2. **Composable Components**: Each conversion step produces intermediate representations
3. **Semantic Preservation**: Maintain query intent through transformation layers
4. **Compass-Centric**: Generate queries optimized for Compass schema characteristics
5. **Parameter Support**: Handle runtime parameters for dynamic queries
6. **Audit Trail**: Include traceability from IMQ to SQL for debugging

---

## Phase Overview

### Phase Structure

The conversion follows distinct logical phases:

```
Phase 1: Parse & Validate
├─ Parse IMQ JSON structure
├─ Validate against IMQ schema
└─ Extract core components (typeOf, where, path, return, etc.)

Phase 2: Entity Resolution
├─ Map IMQ entity types to Compass tables
├─ Resolve property IRIs to Compass columns
├─ Identify required JOINs
└─ Handle concept mappings

Phase 3: Condition Translation
├─ Translate WHERE clauses to SQL conditions
├─ Handle logical operators (AND, OR, NOT)
├─ Process temporal conditions
├─ Translate functions (age calculation, date arithmetic)
└─ Resolve concept references

Phase 4: Join Generation
├─ Build JOIN tree from path specifications
├─ Identify foreign key relationships
├─ Handle self-joins and recursive relationships
└─ Optimize join order

Phase 5: Select Construction
├─ Build SELECT column list from return specifications
├─ Handle property expansion/nesting
├─ Generate aliases for multi-table queries
└─ Include audit columns (date_recorded, etc.)

Phase 6: Query Assembly & Optimization
├─ Combine SELECT, FROM, WHERE, JOIN, ORDER BY, LIMIT
├─ Apply indexes to conditions
├─ Eliminate redundant joins
├─ Add query context (organization_id, patient_id filters)
└─ Generate final SQL
```

---

## IMQ to Compass Entity Mapping

### Mapping Principles

1. **IRI-Based Mapping**: IMQ uses IRIs (Internationalized Resource Identifiers); map to Compass entities
2. **Hierarchical Resolution**: Resolve type hierarchies (Patient → patient table, concepts → concept table)
3. **Multi-table Relationships**: One IMQ entity may require multiple tables/joins
4. **Cardinality Handling**: Recognize 1:1, 1:N, and N:N relationships

### Core Entity Mappings

| IMQ Entity IRI | Compass Table(s) | Primary Key | Note |
|---|---|---|---|
| `http://endhealth.info/im#Patient` | `patient` | `(organization_id, person_id, id)` | Patient demographics |
| `http://endhealth.info/im#EpisodeOfCare` | `episode_of_care` | `(organization_id, person_id, id)` | Registration/enrollment |
| `http://endhealth.info/im#Encounter` | `encounter` | `(organization_id, person_id, id)` | Clinical visits |
| `http://endhealth.info/im#ClinicalEntry` | `observation`, `diagnostic_order`, `medication_statement` | Various | Clinical entries (polymorphic) |
| `http://endhealth.info/im#Observation` | `observation` | `(organization_id, person_id, id)` | Test results, findings |
| `http://endhealth.info/im#Medication` | `medication_statement`, `medication_order` | `(organization_id, person_id, id)` | Medication data |
| `http://endhealth.info/im#Allergy` | `allergy_intolerance` | `(organization_id, person_id, id)` | Allergies/intolerances |
| `http://endhealth.info/im#Appointment` | `appointment` | `(organization_id, person_id, id)` | Scheduled visits |
| `http://endhealth.info/im#Flag` | `flag` | `(organization_id, person_id, id)` | Patient alerts |
| `http://endhealth.info/im#Organization` | `organization` | `id` | Healthcare organization |
| `http://endhealth.info/im#Practitioner` | `practitioner` | `id` | Healthcare professional |
| `http://endhealth.info/im#Concept` | `concept` | `dbid` | Clinical coding/terminology |

### Property Mappings

Core properties mapping IMQ IRIs to Compass columns:

| IMQ Property IRI | Compass Column(s) | Data Type | Mapping Logic |
|---|---|---|---|
| `http://endhealth.info/im#concept` | `core_concept_id` or `non_core_concept_id` | int | Primary concept reference (core first) |
| `http://endhealth.info/im#effectiveDate` | `clinical_effective_date` | datetime | When data was recorded |
| `http://endhealth.info/im#dateOfBirth` | `date_of_birth` | date | Patient birth date |
| `http://endhealth.info/im#age` | Computed from `date_of_birth` | int | Calculate age based on reference date |
| `http://endhealth.info/im#gmsPatientType` | `registration_type_concept_id` | int | Episode of Care registration type |
| `http://endhealth.info/im#status` | `registration_status_concept_id` | int | Episode status |
| `http://endhealth.info/im#resultValue` | `result_value` | double | Observation/test result |
| `http://endhealth.info/im#resultText` | `result_text` | text | Textual result |
| `http://endhealth.info/im#label` | `name` (concept), `first_names`/`last_name` (patient) | varchar | Display name/label |
| `http://www.w3.org/2000/01/rdf-schema#label` | Table-specific name field | varchar | RDF label property |
| `http://endhealth.info/im#dose` | `dose` | varchar | Medication dosage |
| `http://endhealth.info/im#quantity` | `quantity_value`, `quantity_unit` | double, varchar | Medication quantity |
| `http://endhealth.info/im#problem` | `is_problem` | tinyint(1) | Problem flag |
| `http://endhealth.info/im#isActive` | `is_active` | tinyint(1) | Activity flag |

---

## Conversion Pipeline

### 1. Parse & Validate

**Input**: IMQ JSON object  
**Output**: Validated internal IMQ representation

**Steps**:
1. Parse JSON into typed IMQ model (Query, Match, Where, Path, Return objects)
2. Validate required properties exist (at least one of: typeOf, isCohort, path, rule)
3. Extract query components:
   - `typeOf`: Primary entity type
   - `where`: Filter conditions
   - `path`: Navigational relationships (JOINs)
   - `return`: Result projection
   - `and`, `or`, `not`: Logical combinations
   - `rule`: Conditional logic
   - `orderBy`: Result ordering
   - Parameters: Extract runtime parameters

**Error Handling**:
- Invalid JSON structure → Parse error
- Missing required entity type → Validation error
- Malformed property IRIs → Warning (attempt fuzzy matching to mapping file)

---

### 2. Entity Resolution

**Input**: Validated IMQ  
**Output**: Resolved entity/table mappings + JOIN graph

**Steps**:

#### 2.1 Primary Entity Resolution
```
IF typeOf is specified:
  - Lookup IRI in mapping file
  - Get primary Compass table(s)
  - Determine if entity is polymorphic (ClinicalEntry → multiple tables)
  - Get primary key structure
ELSE IF isCohort is specified:
  - Resolve referenced cohort query recursively
ELSE IF path is specified:
  - Resolve starting entity from path[0]
ELSE IF rule is specified:
  - Resolve entity from rule conditions
```

#### 2.2 Property Resolution
```
FOR EACH property reference in query (where, return, path, etc.):
  - Lookup IRI in mapping file
  - Get Compass column name
  - Get data type
  - If concept reference:
    - Mark as requiring concept table join
    - Note if needs concept_map lookup (legacy→core mapping)
```

#### 2.3 Path Navigation & JOIN Identification
```
FOR EACH path element:
  - Resolve source table and target entity
  - Lookup foreign key relationship
  - Identify join condition (e.g., patient.id → encounter.patient_id)
  - Check for cardinality (1:1, 1:N)
  - Mark for LEFT JOIN if optional, INNER JOIN if required
  - Add to JOIN tree
```

**Mapping File Lookup**:
- Use IRI as key
- Support IRI prefix aliases (e.g., `im:Patient` → `http://endhealth.info/im#Patient`)
- Include fallback/fuzzy matching for partial IRIs

---

### 3. Condition Translation

**Input**: WHERE clauses, logical operators, filters  
**Output**: SQL WHERE/HAVING clause components

**Steps**:

#### 3.1 Simple Condition Translation

```
Match {
  iri: "http://endhealth.info/im#concept",
  is: [{iri: "http://snomed.info/sct#123456"}]
}

→ observation.core_concept_id = (
    SELECT dbid FROM concept 
    WHERE id = 'http://snomed.info/sct#123456'
  )
```

#### 3.2 Operator Translation

| IMQ Operator | SQL Operator | Example |
|---|---|---|
| `=` (implicit in `is`) | `=` | `where.value = SQL_value` |
| `!=` (in `is` with negation) | `!=` or `NOT IN` | `where.value != SQL_value` |
| `<` | `<` | `clinical_effective_date < $searchDate` |
| `<=` | `<=` | `clinical_effective_date <= $searchDate` |
| `>` | `>` | `age_at_event > 65` |
| `>=` | `>=` | `result_value >= 7.0` |

#### 3.3 Temporal Condition Translation

```
Match {
  iri: "http://endhealth.info/im#effectiveDate",
  operator: "<=",
  relativeTo: { parameter: "$searchDate" }
}

→ WHERE clinical_effective_date <= @searchDate
```

**Date Handling**:
- `$searchDate` → Parameter bound at query execution
- Implicit conversion of date_precision_concept_id:
  - Precision 1 (year): Compare year only
  - Precision 2 (month): Compare year-month
  - Precision 5 (day): Full date comparison
  - Precision 12+ (time): Include time components

#### 3.4 Function Translation

**Age Calculation**:
```
Match {
  iri: "http://endhealth.info/im#age",
  operator: ">=",
  value: "65"
}

→ WHERE DATEDIFF(YEAR, patient.date_of_birth, @searchDate) >= 65
  OR TIMESTAMPDIFF(YEAR, patient.date_of_birth, @searchDate) >= 65 (MySQL)
```

**Membership Testing**:
```
Match {
  iri: "http://endhealth.info/im#concept",
  is: [{iri: "...", memberOf: true}]
}

→ WHERE core_concept_id IN (
    SELECT core FROM concept_map 
    WHERE legacy = @conceptId
    UNION ALL
    SELECT @conceptId  -- Include the concept itself
  )
```

#### 3.5 Logical Operator Combination

```
Match {
  and: [
    { iri: "...", is: [...] },
    { iri: "...", operator: ">=", value: "..." }
  ]
}

→ WHERE (condition1) AND (condition2)
```

```
Match {
  or: [
    { isCohort: {...} },
    { isCohort: {...} }
  ]
}

→ WHERE (SELECT ... FROM cohort1) UNION (SELECT ... FROM cohort2)
```

#### 3.6 Concept Resolution

**Concept Lookup Strategies**:

1. **Direct Core Concept**: If IRI maps directly to core concept ID
   ```sql
   WHERE core_concept_id = 12345
   ```

2. **Legacy Concept Mapping**: If IRI is legacy/source system code
   ```sql
   WHERE core_concept_id IN (
     SELECT core FROM concept_map 
     WHERE legacy = (SELECT dbid FROM concept WHERE id = 'legacy_iri')
   )
   ```

3. **Concept Set Membership**: If IRI references a concept set
   ```sql
   WHERE core_concept_id IN (
     SELECT member_concept_id FROM concept_set_member 
     WHERE concept_set_id = (SELECT dbid FROM concept WHERE id = 'set_iri')
   )
   ```

4. **Descendant Hierarchy**: With `memberOf: true` or `descendantsOrSelfOf`
   ```sql
   WHERE core_concept_id IN (
     WITH RECURSIVE concept_tree AS (
       SELECT dbid FROM concept WHERE id = 'parent_iri'
       UNION ALL
       SELECT c.dbid FROM concept c
       JOIN concept_hierarchy ch ON c.dbid = ch.child_dbid
       JOIN concept_tree ct ON ch.parent_dbid = ct.dbid
     )
     SELECT dbid FROM concept_tree
   )
   ```

---

### 4. Join Generation

**Input**: Entity mappings + Path specifications  
**Output**: SQL FROM and JOIN clauses

**Steps**:

#### 4.1 Join Tree Construction

```
FROM patient p
  LEFT JOIN episode_of_care eoc ON p.id = eoc.patient_id 
    AND p.organization_id = eoc.organization_id
    AND p.person_id = eoc.person_id
  INNER JOIN encounter e ON p.id = e.patient_id 
    AND p.organization_id = e.organization_id
  LEFT JOIN concept c ON e.core_concept_id = c.dbid
  LEFT JOIN practitioner pr ON e.practitioner_id = pr.id
```

#### 4.2 Join Type Determination

- **INNER JOIN**: Relationship is required for condition filtering
- **LEFT JOIN**: Relationship is optional (for properties in SELECT, or optional conditions)
- **CROSS JOIN**: Rarely used (Cartesian products typically avoided)

#### 4.3 Cardinality-Aware Joining

**1:1 Relationships** (e.g., Patient ↔ Address):
```sql
INNER JOIN patient_address pa ON p.id = pa.patient_id
```

**1:N Relationships** (e.g., Patient → Observations):
```sql
LEFT JOIN observation o ON p.id = o.patient_id 
  AND p.organization_id = o.organization_id
-- May require GROUP BY to avoid row multiplication
```

**N:N via Mapping Tables** (e.g., Concept → Concept Set Members):
```sql
INNER JOIN concept_set_member csm ON c.dbid = csm.member_concept_id
INNER JOIN concept_set cs ON csm.concept_set_id = cs.dbid
```

#### 4.4 Organizational Context

**Every Query Base Filter**:
```sql
WHERE p.organization_id = @organizationId
  AND p.patient_id = @patientId  -- if patient-specific query
```

**Multi-organizational Queries**:
```sql
WHERE p.person_id = @personId
-- Gets all organizations' records for this person
```

---

### 5. Select Construction

**Input**: Return specification  
**Output**: SQL SELECT clause

**Steps**:

#### 5.1 Basic Property Selection

```
Return {
  property: [
    { iri: "http://www.w3.org/2000/01/rdf-schema#label" },
    { iri: "http://endhealth.info/im#code" }
  ]
}

→ SELECT
    c.name AS label,
    c.code AS code
```

#### 5.2 NodeRef Handling (Multi-entity Selection)

```
Return {
  nodeRef: "ClinicalEntry",
  property: [
    { iri: "http://endhealth.info/im#effectiveDate" }
  ]
}

→ SELECT
    CASE 
      WHEN entry_type = 'observation' THEN o.clinical_effective_date
      WHEN entry_type = 'medication' THEN ms.clinical_effective_date
      WHEN entry_type = 'diagnostic' THEN dg.clinical_effective_date
    END AS clinical_effective_date
```

#### 5.3 Nested Property Expansion

```
Return {
  property: [
    {
      iri: "http://endhealth.info/im#status",
      return: {
        property: [
          { iri: "http://www.w3.org/2000/01/rdf-schema#label" }
        ]
      }
    }
  ]
}

→ SELECT
    c_status.name AS status_label
  FROM ...
  LEFT JOIN concept c_status ON e.registration_status_concept_id = c_status.dbid
```

#### 5.4 Implicit Columns (Always Include)

- `id`: Primary identifier
- `organization_id`: Organizational context
- `patient_id`: Patient context (if applicable)
- `person_id`: Person identifier (if applicable)
- `clinical_effective_date`: For temporal queries
- `date_recorded`: Audit trail

---

### 6. Query Assembly & Optimization

**Input**: All clause components  
**Output**: Optimized SQL query

**Steps**:

#### 6.1 Component Assembly

```sql
SELECT [columns from step 5]
FROM [primary table from step 4]
[JOIN clauses from step 4]
WHERE [conditions from step 3]
  AND [organizational filters]
  AND [patient context filters]
[GROUP BY if aggregation needed]
[ORDER BY from orderBy specification]
[LIMIT from orderBy.limit]
```

#### 6.2 Optimization Strategies

1. **Index-Friendly Ordering**: Place highly selective conditions first
   ```sql
   WHERE organization_id = ? (high selectivity)
     AND core_concept_id = ? (indexed)
     AND clinical_effective_date >= ? (indexed range)
   ```

2. **Join Reduction**: Eliminate unnecessary joins
   - Remove joins not referenced in WHERE or SELECT
   - Combine related joins

3. **Concept Mapping Optimization**: Pre-compute concept sets
   - Cache concept hierarchies
   - Use denormalized concept fields when available

4. **Distinct Rows**: Handle cardinality issues
   ```sql
   SELECT DISTINCT p.id, p.first_names, p.last_name
   FROM patient p
   LEFT JOIN observation o ON p.id = o.patient_id
   WHERE o.core_concept_id = ?
   ```

---

## Mapping Configuration File

### File Structure (YAML Format)

```yaml
version: "2.3.0"
compass_database: "Discovery Compass 2.3.0"
description: "IMQ Entity and Property Mappings to Compass Schema"

# Entity Type Mappings
entities:
  "http://endhealth.info/im#Patient":
    table: "patient"
    primary_key: ["organization_id", "person_id", "id"]
    filters:
      organization: "organization_id"
      person: "person_id"
    description: "Patient demographic record"
    
  "http://endhealth.info/im#EpisodeOfCare":
    table: "episode_of_care"
    primary_key: ["organization_id", "person_id", "id"]
    filters:
      organization: "organization_id"
      patient: "patient_id"
    relationships:
      - target: "Patient"
        foreign_key: "patient_id"
        join_type: "INNER"
        
  "http://endhealth.info/im#ClinicalEntry":
    tables: 
      - "observation"
      - "diagnostic_order"
      - "medication_statement"
    discriminator_column: null  # Polymorphic entity
    description: "Base type for clinical entries (polymorphic)"

# Property Mappings
properties:
  "http://endhealth.info/im#concept":
    mappings:
      - entity: "Observation"
        column: "core_concept_id"
        type: "int"
        priority: 1
      - entity: "Observation"
        column: "non_core_concept_id"
        type: "int"
        priority: 2
      - entity: "MedicationStatement"
        column: "core_concept_id"
        type: "int"
        priority: 1
    resolution: "concept_id"  # How to resolve concept references
    
  "http://endhealth.info/im#effectiveDate":
    mappings:
      - entity: "*"
        column: "clinical_effective_date"
        type: "datetime"
    handling: "temporal"  # Special handling for dates
    
  "http://endhealth.info/im#age":
    computed: true
    calculation: "DATEDIFF(YEAR, patient.date_of_birth, @searchDate)"
    requires: ["patient.date_of_birth", "@searchDate"]
    
  "http://www.w3.org/2000/01/rdf-schema#label":
    mappings:
      - entity: "Patient"
        column: "CONCAT(first_names, ' ', last_name)"
        type: "varchar"
      - entity: "Concept"
        column: "description"
        type: "varchar"
      - entity: "*"
        column: "name"
        type: "varchar"

# Temporal References
temporal_parameters:
  "$searchDate":
    description: "The date for which to search"
    default: "CURRENT_DATE"
    type: "date"
  "$achievementDate":
    description: "Reference date for achievement calculations"
    type: "date"
  "$paymentPeriodEnd":
    description: "End of payment period"
    type: "date"

# Concept Resolution Strategies
concept_resolution:
  direct_mapping:
    strategy: "core_concept_id = @conceptId"
  legacy_mapping:
    strategy: "core_concept_id IN (SELECT core FROM concept_map WHERE legacy = @legacyConceptId)"
  concept_set:
    strategy: "core_concept_id IN (SELECT member_concept_id FROM concept_set_member WHERE concept_set_id = @setId)"
  hierarchy:
    strategy: "RECURSIVE_DESCENT"
    requires_cte: true

# Common Joins
joins:
  concept_join:
    source_table: "*"
    source_column: "core_concept_id"
    target_table: "concept"
    target_column: "dbid"
    join_type: "LEFT"
    
  patient_join:
    source_table: "*"
    source_columns: ["patient_id", "organization_id"]
    target_table: "patient"
    target_columns: ["id", "organization_id"]
    join_type: "INNER"
```

### Configuration File Usage

**At Runtime**:
1. Load mapping file at application startup
2. Create in-memory index of IRI → Compass mappings
3. Use IRI prefix resolution for aliases
4. Cache computed property definitions

**Error Handling**:
- IRI not in mapping file → Log warning, attempt fuzzy match
- Property not mapped to entity → Error or skip
- Missing required mapping → Abort conversion

---

## Core Conversion Rules

### Rule 1: Patient Context (Universal)

**Every IMQ query targeting patient data MUST include organizational context**

```
IF query involves Patient, Encounter, Observation, Medication, etc.:
  ADD WHERE patient.organization_id = @organizationId
  ADD patient_id filter if available
```

### Rule 2: Multi-table Concept Resolution

**Concepts can be referenced from multiple tables; resolve appropriately**

```
IF property is "concept" AND table supports both core and non_core:
  PREFER core_concept_id
  ELSE use non_core_concept_id
  HANDLE as LEFT JOIN to concept table
```

### Rule 3: Temporal Precision Handling

**Respect date_precision_concept_id when comparing dates**

```
IF date_precision_concept_id = 1 (year only):
  Compare YEAR(clinical_effective_date) = YEAR(@referenceDate)
ELSE IF date_precision_concept_id = 5 (full date):
  Compare clinical_effective_date = @referenceDate
```

### Rule 4: Polymorphic Entity Handling

**ClinicalEntry can be Observation, DiagnosticOrder, or MedicationStatement**

```
IF typeOf = "ClinicalEntry":
  UNION queries from observation, diagnostic_order, medication_statement
  FILTER each by relevant where conditions
  COMBINE with UNION
```

### Rule 5: Cardinality & Grouping

**1:N joins require aggregation to avoid row multiplication**

```
IF JOIN cardinality is 1:N:
  IF SELECT includes multiple rows per parent:
    ADD GROUP BY parent_id
    Use aggregate functions (COUNT, MAX, MIN, etc.)
  ELSE IF only checking existence:
    Use EXISTS subquery instead of JOIN
```

### Rule 6: Null-Safe Comparisons

**Handle NULL values appropriately**

```
IF condition is "is null":
  Generate WHERE column IS NULL
IF condition is "!= value":
  Generate WHERE (column != value OR column IS NULL)
```

### Rule 7: Concept Set Membership

**memberOf: true means check hierarchy, not just direct match**

```
IF memberOf = true:
  Use recursive query or materialized concept hierarchy
  Return all descendants of referenced concept
ELSE:
  Direct concept_id match only
```

---

## Advanced Patterns

### Pattern 1: Cohort References

**isCohort directive references another query as pre-filter**

```
Query A {
  isCohort: Q_RegisteredGMS
}

Resolution:
→ Resolve Q_RegisteredGMS to SQL subquery
→ Use as WHERE condition
  WHERE patient.id IN (SELECT id FROM Q_RegisteredGMS query)
```

### Pattern 2: Multi-Rule Evaluation Pipeline

**Rule arrays define sequential decision trees**

```
rule: [
  {
    ifTrue: "SELECT",      // Include patient
    ifFalse: "NEXT",       // Check next rule
    where: { age < 80 }
  },
  {
    ifTrue: "SELECT",      // Include patient
    ifFalse: "REJECT",     // Exclude patient
    where: { has_BP_reading }
  }
]

SQL Generation:
→ IF age < 80 THEN SELECT (SELECT * FROM patient WHERE age < 80)
→ ELSE IF has_BP_reading THEN SELECT (SELECT * FROM patient WHERE has_BP_reading)
→ ELSE SELECT NOTHING

Simplified: SELECT * FROM patient WHERE (age < 80) OR (has_BP_reading AND age >= 80)
```

### Pattern 3: Nested Path Navigation

```
path: [
  { iri: episodeOfCare, variable: "Episode" },
  { iri: encounter, variable: "Encounter" }
]

Translation:
→ FROM patient p
  LEFT JOIN episode_of_care eoc ON p.id = eoc.patient_id
  LEFT JOIN encounter e ON eoc.id = e.episode_of_care_id
```

### Pattern 4: Complex Temporal Aggregations

```
Find patients with diabetes code AND no recent BP reading

where: {
  and: [
    { concept: diabetes_code, effectiveDate <= $achievementDate },
    { not: [
        { concept: bp_code, effectiveDate >= DATE_SUB($achievementDate, INTERVAL 12 MONTH) }
      ]
    }
  ]
}

SQL:
→ SELECT p.id
  FROM patient p
  INNER JOIN observation o_diabetes ON p.id = o_diabetes.patient_id
    AND o_diabetes.core_concept_id = ?
    AND o_diabetes.clinical_effective_date <= @achievementDate
  LEFT JOIN observation o_bp ON p.id = o_bp.patient_id
    AND o_bp.core_concept_id = ?
    AND o_bp.clinical_effective_date >= DATE_SUB(@achievementDate, INTERVAL 12 MONTH)
  WHERE o_bp.id IS NULL  // No recent BP reading
```

### Pattern 5: Concept Hierarchy Expansion

```
where: {
  concept: "hypertension_parent",
  memberOf: true
}

Translates to:
→ WITH RECURSIVE concept_descendants AS (
    SELECT dbid FROM concept WHERE id = 'hypertension_parent'
    UNION ALL
    SELECT c.dbid FROM concept c
    INNER JOIN concept_hierarchy ch ON c.dbid = ch.child_dbid
    INNER JOIN concept_descendants cd ON ch.parent_dbid = cd.dbid
  )
  SELECT p.id FROM patient p
  INNER JOIN observation o ON p.id = o.patient_id
  WHERE o.core_concept_id IN (SELECT dbid FROM concept_descendants)
```

---

## Implementation Phases

### Implementation Phase 1: Foundation (MVP)

**Scope**: Basic IMQ to SQL for simple queries

**Deliverables**:
- Core IMQ parser
- Entity resolution engine (basic)
- Simple WHERE clause translator
- Basic SELECT generation
- JOIN generation for linear paths

**Capabilities**:
- Single entity type queries
- Basic AND/OR conditions
- Simple temporal filtering
- Basic property selection
- Linear path navigation (Patient → Encounter → Observation)

**Out of Scope**:
- Rules and conditional logic
- Cohort references
- Complex aggregations
- Polymorphic entities
- Recursive concept hierarchies

---

### Implementation Phase 2: Core Features

**Scope**: Essential clinical query patterns

**Deliverables**:
- Advanced WHERE clause handling (NOT, complex operators)
- Concept resolution (basic + legacy mapping)
- Rule evaluation engine
- Cohort reference resolution
- Date precision handling
- Aggregation and grouping

**Capabilities**:
- All Phase 1 features PLUS
- Rule-based conditional logic
- Cohort pre-filtering
- Concept set membership
- Multi-table concept resolution
- Temporal aggregations

---

### Implementation Phase 3: Advanced Features

**Scope**: Complex healthcare-specific patterns

**Deliverables**:
- Polymorphic entity handling
- Recursive concept hierarchies
- Complex aggregations
- Nested path navigation
- Query optimization
- Performance tuning

**Capabilities**:
- All Phase 2 features PLUS
- ClinicalEntry polymorphism
- Concept hierarchy expansion
- Complex multi-table aggregations
- Nested WHERE conditions
- Query plan optimization

---

### Implementation Phase 4: Production Hardening

**Scope**: Reliability, performance, testing

**Deliverables**:
- Comprehensive error handling
- Query validation framework
- Performance testing suite
- Integration tests with Compass
- Documentation and examples
- Monitoring and logging

**Capabilities**:
- Production-ready error handling
- Query execution tracking
- Performance metrics
- Audit trail logging
- Query caching (optional)
- Batch query processing

---

## Edge Cases and Special Handling

### Edge Case 1: Polymorphic ClinicalEntry

**Problem**: "ClinicalEntry" can be Observation, DiagnosticOrder, or MedicationStatement

**Solution**:
```sql
(SELECT o.*, 'observation' as entry_type FROM observation o WHERE o.core_concept_id = ?)
UNION
(SELECT dg.*, 'diagnostic_order' as entry_type FROM diagnostic_order dg WHERE dg.core_concept_id = ?)
UNION
(SELECT ms.*, 'medication_statement' as entry_type FROM medication_statement ms WHERE ms.core_concept_id = ?)
```

### Edge Case 2: Missing organization_id Context

**Problem**: Query doesn't specify organization context

**Solution**:
- Require organization context as runtime parameter
- Default to current user's organization
- Log warning if context missing
- Multi-org queries explicitly request `DISTINCT person_id`

### Edge Case 3: Complex Concept Hierarchies

**Problem**: memberOf requires traversing SNOMED concept trees

**Solution**:
- Implement materialized concept hierarchy tables
- Pre-compute descendant relationships
- Cache hierarchy traversals
- Use recursive CTEs for dynamic queries

### Edge Case 4: Age Calculation Across Years

**Problem**: Patient's age changes; affects historical queries

**Solution**:
```sql
DATEDIFF(YEAR, patient.date_of_birth, 
  CASE 
    WHEN o.clinical_effective_date IS NOT NULL THEN o.clinical_effective_date
    WHEN @searchDate IS NOT NULL THEN @searchDate
    ELSE CURRENT_DATE
  END
) >= 65
```

### Edge Case 5: Date Precision Mismatch

**Problem**: Condition specifies "equals" but precision is year-only

**Solution**:
```sql
WHERE YEAR(clinical_effective_date) = YEAR(@searchDate)
  AND date_precision_concept_id IN (1, 2, 5, 12, 13, 14)
```

### Edge Case 6: NULL in Concept References

**Problem**: core_concept_id or non_core_concept_id might be NULL

**Solution**:
```sql
WHERE (core_concept_id = ? OR (core_concept_id IS NULL AND non_core_concept_id = ?))
```

### Edge Case 7: Circular Cohort References

**Problem**: Cohort A references Cohort B references Cohort A

**Solution**:
- Maintain visited cohort set during recursion
- Detect cycles and raise error
- Alternatively, inline cohort definitions to prevent cycles

### Edge Case 8: Large Result Sets

**Problem**: Query returns millions of rows

**Solution**:
- Always include LIMIT in orderBy
- Use DISTINCT sparingly (performance impact)
- Consider pagination for large results
- Generate explain plans for queries > 1M rows

### Edge Case 9: Temporal Boundary Conditions

**Problem**: "less than" vs "less than or equal to" in achievement windows

**Solution**:
```
If parameter says "up to and including 2024-03-31":
  Use: clinical_effective_date <= '2024-03-31 23:59:59.999'
If parameter says "before 2024-04-01":
  Use: clinical_effective_date < '2024-04-01 00:00:00'
```

### Edge Case 10: Additional Data Tables

**Problem**: observation_additional, encounter_additional extend main tables

**Solution**:
```sql
LEFT JOIN observation_additional oa ON o.id = oa.id AND oa.property_id = @propertyId
WHERE oa.value_id = ? OR oa.text_value = ?
```

---

## Error Handling Strategy

### Parse Errors
- **Cause**: Invalid JSON or malformed IMQ structure
- **Handling**: Return parse error with line number
- **Recovery**: Suggest valid structure

### Resolution Errors
- **Cause**: IRI not found in mapping file
- **Handling**: Attempt fuzzy matching; log warning
- **Recovery**: Default to closest match or fail conversion

### Semantic Errors
- **Cause**: Conflicting conditions (AND with contradictory values)
- **Handling**: Detect and warn; may result in empty result set
- **Recovery**: User review required

### SQL Generation Errors
- **Cause**: Unsupported combination of IMQ features
- **Handling**: Abort conversion; provide error message
- **Recovery**: Simplify query or file enhancement request

---

## Performance Considerations

### Index Strategy
- **organization_id**: Always indexed (multi-org queries)
- **core_concept_id**: Indexed (concept filtering)
- **clinical_effective_date**: Indexed (temporal filtering)
- **patient_id + organization_id**: Composite index
- **person_id**: Indexed (cross-org queries)

### Query Optimization Tips
1. Place most selective conditions first
2. Use INNER JOIN for mandatory relationships
3. Limit result sets early
4. Cache concept hierarchies
5. Materialize frequently-used concept sets

---

## Configuration Management

### Loading Mapping File
```yaml
# At startup:
1. Read mapping file (YAML/JSON)
2. Build in-memory index of IRI → Compass mappings
3. Pre-compile common queries (registered cohorts)
4. Cache concept hierarchies
5. Initialize parameter system
```

### Updating Mappings
- Support hot-reload of mapping file
- Versioning of mapping files (for backward compatibility)
- Audit trail of mapping changes
- Validation before applying new mappings

---

## Testing Strategy

### Unit Test Coverage
- IMQ parsing (valid and invalid inputs)
- Entity resolution (correct table mapping)
- Condition translation (all operators, combinations)
- JOIN generation (various cardinalities)
- SELECT generation (with/without nesting)

### Integration Test Coverage
- Execute generated SQL against Compass test database
- Validate result sets match expected outcomes
- Performance testing (query execution times)
- Large dataset testing (millions of rows)

### Regression Testing
- Maintain repository of known query patterns
- Re-test after any conversion logic changes
- Track performance metrics over time

---

## Conclusion

This plan provides a comprehensive roadmap for implementing IMQ to SQL conversion with:

1. **Configurable mapping** that bridges semantic and relational models
2. **Phased implementation** allowing iterative value delivery
3. **Clear conversion rules** for reliable, predictable translations
4. **Advanced pattern support** for complex healthcare queries
5. **Production readiness** through error handling and optimization

The modular architecture allows each component (parser, resolver, translator, generator) to be developed, tested, and optimized independently while maintaining integration coherence.

### Next Steps

1. **Finalize mapping file**: Define all IMQ IRIs and Compass column mappings
2. **Develop IMQ parser**: Create typed data structures for IMQ validation
3. **Build entity resolver**: Implement mapping file lookup and JOIN graph construction
4. **Implement condition translator**: Generate WHERE clause SQL from IMQ conditions
5. **Create query assembler**: Combine components into final SQL
6. **Test and optimize**: Run against Compass database with real-world queries