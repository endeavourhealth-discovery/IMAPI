# IMQuery Language Specification

## Introduction

IMQuery (Information Manager Query) is a JSON-based query language designed for expressing complex clinical and patient selection queries over semantic health information models. IMQuery serves as an intermediate query language that bridges high-level clinical specifications (such as QOF specifications) with executable SQL queries against underlying databases.

This document defines the syntax, structure, and semantics of the IMQuery language based on standard patterns observed in real-world implementations.

---

## Overview

IMQuery queries are expressed as JSON objects that describe:
- **What data to query** - Entity types and relationships
- **How to filter data** - Conditions and logical operations
- **What to return** - Selected properties and transformations
- **How to branch** - Conditional logic and rule-based evaluation

---

## Root Query Structure

### Basic Query Template

```json
{
  "iri": "string",
  "name": "string",
  "description": "string",
  "typeOf": {
    "iri": "string"
  },
  "activeOnly": boolean,
  "where": { ... },
  "return": { ... },
  "variable": "string",
  "instanceOf": [ ... ],
  "isCohort": { ... },
  "rule": [ ... ],
  "and": [ ... ],
  "or": [ ... ],
  "path": [ ... ],
  "query": [ ... ],
  "prefixes": { ... },
  "bindAs": "string"
}
```

### Java Implementation

The IMQuery structure is implemented as the `Query` class located at:
`src/main/java/org/endeavourhealth/imapi/model/imq/Query.java`

**Key Properties and Methods:**
```java
@JsonPropertyOrder({"prefix", "iri", "name", "description", "query","activeOnly", 
                    "typeOf","isCohort","instanceOf", "and", "or", "not", "path", 
                    "where", "return", "groupBy", "dataSet"})
@JsonInclude(JsonInclude.Include.NON_DEFAULT)
public class Query extends Match {
  // Core properties
  private String iri;
  private String name;
  private String description;
  private Prefixes prefixes;
  private boolean activeOnly;
  private List<Query> query;
  private JsonNode parentResult;
  private TTIriRef persistentIri;
  private String bindAs;
  private boolean imQuery;
  private List<Match> columnGroup;
  
  // Fluent setters
  public Query setQuery(List<Query> query) { ... }
  public Query addQuery(Query query) { ... }
  public Query setParameter(String parameter) { ... }
  public Query setBindAs(String bindAs) { ... }
  public Query setPrefixes(Prefixes prefixes) { ... }
  public Query addPrefix(String prefix, String namespace) { ... }
  public Query setIri(String iri) { ... }
  public Query setName(String name) { ... }
  public Query setDescription(String description) { ... }
  public Query setActiveOnly(boolean activeOnly) { ... }
  
  // Navigation and filtering
  public Query setAnd(List<Match> and) { ... }
  public Query addAnd(Match and) { ... }
  public Query and(Consumer<Match> builder) { ... }
  public Query setOr(List<Match> or) { ... }
  public Query addOr(Match or) { ... }
  public Query or(Consumer<Match> builder) { ... }
  public Query setNot(List<Match> not) { ... }
  public Query addNot(Match not) { ... }
  public Query not(Consumer<Match> builder) { ... }
  
  // Path navigation
  public Query setPath(List<Path> path) { ... }
  public Query addPath(Path path) { ... }
  public Query path(Consumer<Path> builder) { ... }
  
  // WHERE and RETURN clauses
  public Query setWhere(Where where) { ... }
  public Query where(Consumer<Where> builder) { ... }
  public Query setReturn(Return returx) { ... }
  public Query return_(Consumer<Return> builder) { ... }
  
  // Type and cohort specifications
  public Query setTypeOf(String type) { ... }
  public Query setInstanceOf(List<Node> instanceOf) { ... }
  public Query addInstanceOf(Node instanceOf) { ... }
  public Query instanceOf(Consumer<Node> builder) { ... }
  
  // Grouping and ordering
  public Query setGroupBy(List<GroupBy> groupBy) { ... }
  public Query addGroupBy(GroupBy group) { ... }
  public Query groupBy(Consumer<GroupBy> builder) { ... }
  public Query setOrderBy(OrderLimit orderBy) { ... }
  
  // Utility properties
  public Query setImQuery(boolean imQuery) { ... }
  public Query setVariable(String variable) { ... }
  public Query setBaseRule(boolean baseRule) { ... }
  public Query setPersistentIri(TTIriRef persistentIri) { ... }
}
```

### Root Properties

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `iri` | string | No | Unique identifier (IRI) for the query itself |
| `name` | string | Yes | Human-readable name of the query |
| `description` | string | No | Detailed description of what the query does |
| `typeOf` | object | No | Specifies the primary entity type being queried |
| `activeOnly` | boolean | No | When `true`, only returns active (non-deleted) entities |
| `where` | object | No | Filtering conditions for the query |
| `return` | object | No | Specifies which properties to return in results |
| `variable` | string | No | Name for referencing this query result |
| `instanceOf` | array | No | Array of type membership conditions |
| `isCohort` | object | No | Reference to another query as a pre-filter (cohort base) |
| `rule` | array | No | Array of conditional rules to apply |
| `and` | array | No | Array of conditions to AND together |
| `or` | array | No | Array of conditions to OR together |
| `not` | array | No | Array of conditions to negate |
| `path` | array | No | Navigational path through entity relationships |
| `query` | array | No | Array of nested Query objects for complex query composition |
| `prefixes` | object | No | Namespace prefix definitions for IRIs |
| `bindAs` | string | No | Variable name to bind query results to |
| `groupBy` | array | No | Array of grouping specifications |
| `orderBy` | object | No | Ordering and limit specifications |
| `columnGroup` | array | No | Array of column groupings for result structuring |

---

## Entity Type Specification

### typeOf Object

Specifies the type of entity being queried. Uses IRIs (Internationalized Resource Identifiers) to reference entity types.

```json
{
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  }
}
```

### Common Entity Types

| IRI | Description |
|-----|-------------|
| `http://endhealth.info/im#Patient` | A patient entity |
| `http://endhealth.info/im#Concept` | A concept in the ontology |
| `http://endhealth.info/im#ConceptSet` | A set of related concepts |
| `http://endhealth.info/im#ValueSet` | A value set definition |
| `http://endhealth.info/im#EpisodeOfCare` | An episode of care record |
| `http://endhealth.info/im#ClinicalEntry` | A clinical observation/entry |
| `http://endhealth.info/im#Property` | A data model property |

---

## Filtering: The WHERE Clause

The `where` clause defines conditions that entities must satisfy.

### Simple WHERE Clause

```json
{
  "where": {
    "iri": "http://endhealth.info/im#concept",
    "is": [
      {
        "iri": "http://snomed.info/sct#999004691000230108",
        "memberOf": true
      }
    ]
  }
}
```

### WHERE Clause Properties

| Property | Type | Description |
|----------|------|-------------|
| `iri` | string | The property IRI to evaluate (e.g., `http://endhealth.info/im#concept`) |
| `is` | array | Array of values the property should equal |
| `isNull` | boolean | When `true`, checks if property is null |
| `operator` | string | Comparison operator (see below) |
| `value` | string/number | Value to compare against |
| `relativeTo` | object | Relative date reference for temporal comparisons |
| `memberOf` | boolean | When `true`, checks membership in a set |
| `nodeRef` | string | Reference to a variable for qualified evaluation |
| `inverse` | boolean | When `true`, inverts the relationship direction |
| `and` | array | Array of conditions to AND together |
| `or` | array | Array of conditions to OR together |

### Comparison Operators

| Operator | Description |
|----------|-------------|
| `=` | Equal to |
| `!=` | Not equal to |
| `<` | Less than |
| `<=` | Less than or equal to |
| `>` | Greater than |
| `>=` | Greater than or equal to |

### Temporal References

Temporal comparisons often use relative dates:

```json
{
  "iri": "http://endhealth.info/im#effectiveDate",
  "operator": "<=",
  "relativeTo": {
    "parameter": "$achievementDate"
  }
}
```

#### Common Temporal Parameters

| Parameter | Description |
|-----------|-------------|
| `$achievementDate` | The reference date for achievement calculations |
| `$searchDate` | The date for which to search (e.g., current date) |
| `$paymentPeriodEnd` | Payment period end date |

### Filtering with Functions

Some filters use computed functions:

```json
{
  "iri": "http://endhealth.info/im#age",
  "operator": ">=",
  "value": "17",
  "relativeTo": {
    "parameter": "$searchDate"
  },
  "units": {
    "name": "Years",
    "iri": "http://endhealth.info/im#Years"
  },
  "function": {
    "iri": "http://endhealth.info/im#age",
    "argument": [
      {
        "parameter": "dateOfBirth",
        "valuePath": {
          "iri": "http://endhealth.info/im#dateOfBirth"
        }
      },
      {
        "parameter": "relativeTo",
        "valueParameter": "$searchDate"
      },
      {
        "parameter": "units",
        "valueIri": {
          "name": "Years",
          "iri": "http://endhealth.info/im#Years"
        }
      }
    ]
  }
}
```

---

## Logical Operations

### AND Conditions

Multiple conditions can be combined with AND logic. All conditions must be satisfied:

```json
{
  "and": [
    {
      "iri": "http://endhealth.info/im#gmsPatientType",
      "is": [
        {
          "iri": "http://hl7.org/fhir/registration-type/r"
        }
      ]
    },
    {
      "iri": "http://endhealth.info/im#effectiveDate",
      "operator": "<=",
      "relativeTo": {
        "parameter": "$searchDate"
      }
    }
  ]
}
```

### OR Conditions

Multiple conditions can be combined with OR logic. At least one condition must be satisfied:

```json
{
  "or": [
    {
      "isCohort": {
        "name": "Blood Pressure reading at home",
        "iri": "http://endhealth.info/qof#683a4829-e32c-4e1e-945e-a8c675ffe49c"
      }
    },
    {
      "isCohort": {
        "name": "Blood Pressure reading excluding home",
        "iri": "http://endhealth.info/qof#799c03c7-d685-4adf-b360-821b2194fcc2"
      }
    }
  ]
}
```

### NOT Conditions

Conditions can be negated:

```json
{
  "not": [
    {
      "iri": "http://endhealth.info/im#effectiveDate",
      "operator": ">",
      "relativeTo": {
        "parameter": "$achievementDate"
      }
    }
  ]
}
```

---

## Path Navigation

The `path` property enables traversal through entity relationships.

### PATH Structure

```json
{
  "path": [
    {
      "iri": "http://endhealth.info/im#episodeOfCare",
      "variable": "RegistrationEpisode",
      "typeOf": {
        "iri": "http://endhealth.info/im#EpisodeOfCare"
      }
    }
  ],
  "where": {
    "iri": "http://endhealth.info/im#gmsPatientType",
    "nodeRef": "RegistrationEpisode",
    "is": [
      {
        "iri": "http://hl7.org/fhir/registration-type/r"
      }
    ]
  }
}
```

### PATH Properties

| Property | Type | Description |
|----------|------|-------------|
| `iri` | string | The relationship IRI to traverse |
| `variable` | string | Name for the target entity (used in `nodeRef` later) |
| `typeOf` | object | Type specification for the target entity |
| `where` | object | Additional filtering on the path |

### Node References

The `nodeRef` property qualifies conditions to apply to a specific variable:

```json
{
  "iri": "http://endhealth.info/im#effectiveDate",
  "nodeRef": "RegistrationEpisode",
  "operator": "<=",
  "relativeTo": {
    "parameter": "$searchDate"
  }
}
```

---

## Return Specifications

The `return` clause specifies which properties to include in query results.

### Simple Return

```json
{
  "return": {
    "property": [
      {
        "iri": "http://www.w3.org/2000/01/rdf-schema#label"
      },
      {
        "iri": "http://endhealth.info/im#code"
      }
    ]
  }
}
```

### Return with Node Reference

```json
{
  "return": {
    "nodeRef": "ClinicalEntry",
    "property": [
      {
        "iri": "http://www.w3.org/2000/01/rdf-schema#label"
      },
      {
        "iri": "http://endhealth.info/im#code"
      }
    ]
  }
}
```

### Nested Returns (Property Expansion)

Properties can be expanded to include their sub-properties:

```json
{
  "return": {
    "property": [
      {
        "iri": "http://endhealth.info/im#status",
        "return": {
          "property": [
            {
              "iri": "http://www.w3.org/2000/01/rdf-schema#label"
            }
          ]
        }
      }
    ]
  }
}
```

### Return Properties

| Property | Type | Description |
|----------|------|-------------|
| `nodeRef` | string | Variable specifying which entity to return |
| `property` | array | Array of property IRIs to include |
| `return` | object | Nested return specification for property expansion |

---

## Cohort References and Rules

### Cohort References

Queries can reference other queries (cohorts) as a base population:

```json
{
  "isCohort": {
    "name": "Registered with GP for GMS services",
    "iri": "http://endhealth.info/im#Q_RegisteredGMS"
  }
}
```

### Rule-Based Conditional Logic

Rules enable step-by-step evaluation with branching:

```json
{
  "rule": [
    {
      "ifTrue": "NEXT",
      "ifFalse": "REJECT",
      "description": "Patient Age is less than 80",
      "where": {
        "iri": "http://endhealth.info/im#age",
        "operator": "<",
        "value": "80"
      }
    },
    {
      "ifTrue": "SELECT",
      "ifFalse": "NEXT",
      "and": [
        {
          "isCohort": {
            "name": "Blood Pressure reading in last 12 months",
            "iri": "http://endhealth.info/qof#683a4829-e32c-4e1e-945e-a8c675ffe49c"
          }
        }
      ]
    }
  ]
}
```

### Rule Properties

| Property | Type | Description |
|----------|------|-------------|
| `ifTrue` | string | Action when condition is true: `SELECT`, `REJECT`, `NEXT` |
| `ifFalse` | string | Action when condition is false: `SELECT`, `REJECT`, `NEXT` |
| `description` | string | Human-readable description of the rule |
| `where` | object | Condition to evaluate |
| `and` | array | Conditions to AND together |
| `or` | array | Conditions to OR together |
| `isCohort` | object | Reference to another cohort |

### Rule Actions

| Action | Description |
|--------|-------------|
| `SELECT` | Include the entity in results; evaluation complete |
| `REJECT` | Exclude the entity from results; evaluation complete |
| `NEXT` | Continue to the next rule |

---

## Instance Membership Conditions

The `instanceOf` clause filters entities by type membership:

```json
{
  "instanceOf": [
    {
      "parameter": "this",
      "descendantsOrSelfOf": true
    }
  ]
}
```

### Instance Membership Properties

| Property | Type | Description |
|----------|------|-------------|
| `parameter` | string | Parameter name or reference |
| `descendantsOrSelfOf` | boolean | Include descendants of the type |
| `ancestorsOrSelfOf` | boolean | Include ancestors of the type |

---

## Ordering and Limiting Results

Results can be ordered and limited:

```json
{
  "path": [
    {
      "iri": "http://endhealth.info/im#clinicalEntry",
      "variable": "ClinicalEntry"
    }
  ],
  "orderBy": {
    "property": [
      {
        "iri": "http://endhealth.info/im#effectiveDate",
        "nodeRef": "ClinicalEntry",
        "direction": "descending"
      }
    ],
    "limit": 1
  }
}
```

### Order Properties

| Property | Type | Description |
|----------|------|-------------|
| `property` | array | Properties to sort by |
| `direction` | string | `ascending` or `descending` |
| `limit` | integer | Maximum number of results |
| `iri` | string | Property IRI for the variable specified by `nodeRef` |
| `nodeRef` | string | Variable reference |

---

## Advanced Features

### Keeping Intermediate Results

The `keepAs` property stores intermediate results for later reference:

```json
{
  "path": [
    {
      "iri": "http://endhealth.info/im#clinicalEntry",
      "variable": "ClinicalEntry"
    }
  ],
  "where": {
    "iri": "http://endhealth.info/im#concept",
    "is": [
      {
        "iri": "http://snomed.info/sct#999004691000230108"
      }
    ]
  },
  "keepAs": "Match_196",
  "orderBy": {
    "property": [
      {
        "iri": "http://endhealth.info/im#effectiveDate",
        "direction": "descending"
      }
    ],
    "limit": 1
  }
}
```

### Nested Path Conditions (then clause)

Complex queries can use nested conditions with `then`:

```json
{
  "then": {
    "not": [
      {
        "path": [
          {
            "iri": "http://endhealth.info/im#clinicalEntry",
            "variable": "ClinicalEntry"
          }
        ],
        "where": {
          "iri": "http://endhealth.info/im#concept",
          "is": [
            {
              "iri": "http://snomed.info/sct#999003371000230102"
            }
          ]
        }
      }
    ]
  }
}
```

### Query Entailment

The `entailment` property can specify reasoning:

```json
{
  "entailment": "descendantsOrSelfOf"
}
```

Supported entailment types:
- `descendantsOrSelfOf` - Include descendants in type hierarchy
- `ancestorsOf` - Include ancestors in type hierarchy

---

## Common Query Patterns

### Pattern 1: Simple Entity Type Query

Find all active concepts of a specific type:

```json
{
  "name": "Search for concepts of $this type",
  "description": "of type $this",
  "activeOnly": true,
  "typeOf": {
    "parameter": "this"
  },
  "return": {
    "property": [
      {
        "iri": "http://www.w3.org/2000/01/rdf-schema#label"
      },
      {
        "iri": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
      }
    ]
  }
}
```

### Pattern 2: Patient Selection with Registration Status

Select patients registered as GMS on a reference date:

```json
{
  "name": "Patient registered as GMS on the reference date",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "and": [
    {
      "path": [
        {
          "iri": "http://endhealth.info/im#episodeOfCare",
          "variable": "RegistrationEpisode",
          "typeOf": {
            "iri": "http://endhealth.info/im#EpisodeOfCare"
          }
        }
      ],
      "where": {
        "and": [
          {
            "iri": "http://endhealth.info/im#gmsPatientType",
            "nodeRef": "RegistrationEpisode",
            "is": [
              {
                "iri": "http://hl7.org/fhir/registration-type/r"
              }
            ]
          },
          {
            "iri": "http://endhealth.info/im#effectiveDate",
            "operator": "<=",
            "relativeTo": {
              "parameter": "$searchDate"
            },
            "nodeRef": "RegistrationEpisode"
          }
        ]
      }
    }
  ]
}
```

### Pattern 3: Clinical Diagnosis with Negation

Find patients with unresolved diabetes:

```json
{
  "name": "Patient having unresolved Diabetes code",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "rule": [
    {
      "ifTrue": "SELECT",
      "ifFalse": "REJECT",
      "path": [
        {
          "iri": "http://endhealth.info/im#clinicalEntry",
          "variable": "ClinicalEntry",
          "typeOf": {
            "iri": "http://endhealth.info/im#ClinicalEntry"
          }
        }
      ],
      "where": {
        "and": [
          {
            "iri": "http://endhealth.info/im#concept",
            "nodeRef": "ClinicalEntry",
            "is": [
              {
                "iri": "http://snomed.info/sct#999004691000230108",
                "memberOf": true
              }
            ]
          },
          {
            "iri": "http://endhealth.info/im#effectiveDate",
            "operator": "<=",
            "relativeTo": {
              "parameter": "$achievementDate"
            },
            "nodeRef": "ClinicalEntry"
          }
        ]
      },
      "then": {
        "not": [
          {
            "path": [
              {
                "iri": "http://endhealth.info/im#clinicalEntry",
                "variable": "ClinicalEntry"
              }
            ],
            "where": {
              "and": [
                {
                  "iri": "http://endhealth.info/im#concept",
                  "is": [
                    {
                      "iri": "http://snomed.info/sct#999003371000230102",
                      "memberOf": true
                    }
                  ]
                }
              ]
            }
          }
        ]
      }
    }
  ]
}
```

### Pattern 4: Multi-Rule Indicator Logic

Complex indicator with multiple rules and cohort references:

```json
{
  "name": "HYP009 - Hypertension aged 80 or over BP 150/90 mmHg or less",
  "typeOf": {
    "iri": "http://endhealth.info/im#Patient"
  },
  "isCohort": {
    "name": "Registered with GP for GMS services",
    "iri": "http://endhealth.info/im#Q_RegisteredGMS"
  },
  "rule": [
    {
      "ifTrue": "SELECT",
      "ifFalse": "NEXT",
      "and": [
        {
          "isCohort": {
            "name": "Blood Pressure at home criteria",
            "iri": "http://endhealth.info/qof#683a4829-e32c-4e1e-945e-a8c675ffe49c"
          }
        },
        {
          "isCohort": {
            "name": "BP date comparison",
            "iri": "http://endhealth.info/qof#9ccf8231-ee93-4b16-9356-ce23e37e7d86"
          }
        }
      ]
    },
    {
      "ifTrue": "SELECT",
      "ifFalse": "REJECT",
      "and": [
        {
          "isCohort": {
            "name": "Blood Pressure excluding home criteria",
            "iri": "http://endhealth.info/qof#799c03c7-d685-4adf-b360-821b2194fcc2"
          }
        }
      ]
    }
  ]
}
```

---

## Parameter System

IMQuery supports parameterized queries for reusability:

### Parameter References

```json
{
  "parameter": "this"
}
```

Parameters can be passed at query execution time to customize behavior.

### Built-in Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `$searchDate` | Date | The date for which to perform the search |
| `$achievementDate` | Date | The reference date for achievement calculations |
| `$paymentPeriodEnd` | Date | End of the payment period |
| `this` | Entity | The entity being evaluated (used in cohort references) |

---

## Validation and Best Practices

### Required Properties

- At least one of the following must be present: `typeOf`, `isCohort`, `path`, or `rule`
- `name` is recommended for all top-level queries
- Results-focused queries should include `return`

### Structure Guidelines

1. **Single Responsibility** - Each query should represent a single logical concept
2. **Reusable Cohorts** - Define frequently-used queries as cohorts for reference
3. **Clear Descriptions** - Include descriptive names and descriptions for maintainability
4. **Proper Typing** - Specify `typeOf` to clarify the entity types being queried
5. **Temporal Consistency** - Use consistent date parameters throughout a query

### Performance Considerations

- Use `activeOnly: true` when deleted entities should be excluded
- Limit results early with ordering and limiting
- Avoid deeply nested paths when possible
- Use cohort references to prevent query duplication

---

## Example Queries

### Example 1: Get All Descendants

```json
{
  "name": "All subtypes of an entity, active only",
  "description": "Is a descendant of, or $this",
  "activeOnly": true,
  "instanceOf": [
    {
      "parameter": "this",
      "descendantsOrSelfOf": true
    }
  ],
  "return": {
    "nodeRef": "isa",
    "property": [
      {
        "iri": "http://www.w3.org/2000/01/rdf-schema#label"
      },
      {
        "iri": "http://endhealth.info/im#code"
      }
    ]
  },
  "variable": "isa"
}
```

### Example 2: Search Main Types

```json
{
  "name": "Search for all main types",
  "description": "Search for Concepts, Concept Sets, Folders, Value Sets or Data Model Properties",
  "activeOnly": true,
  "and": [
    {
      "or": [
        {
          "name": "Concepts",
          "typeOf": {
            "iri": "http://endhealth.info/im#Concept"
          }
        },
        {
          "name": "Concept sets",
          "typeOf": {
            "iri": "http://endhealth.info/im#ConceptSet"
          }
        },
        {
          "name": "Value Sets",
          "typeOf": {
            "iri": "http://endhealth.info/im#ValueSet"
          }
        }
      ]
    }
  ],
  "return": {
    "property": [
      {
        "iri": "http://www.w3.org/2000/01/rdf-schema#label"
      },
      {
        "iri": "http://endhealth.info/im#code"
      }
    ]
  }
}
```

---

## Grammar Summary

### Query Grammar (BNF-like notation)

```
Query ::= {
  (name String)?,
  (description String)?,
  (typeOf TypeSpecification)?,
  (where WhereClause)?,
  (and [Condition])?
  (or [Condition])?
  (not [Condition])?
  (return ReturnSpecification)?,
  (rule [Rule])?
  (isCohort CohortReference)?,
  (path [PathSpecification])?
  (activeOnly Boolean)?
  (variable String)?
}

TypeSpecification ::= {
  iri String
}

WhereClause ::= {
  (iri String)?,
  (is [Value])?
  (operator Operator)?
  (value Value)?
  (relativeTo DateReference)?
  (and [Condition])?
  (or [Condition])?
  (nodeRef String)?
}

Operator ::= "=" | "!=" | "<" | "<=" | ">" | ">="

Rule ::= {
  ifTrue Action,
  ifFalse Action,
  (description String)?,
  (where WhereClause)?,
  (and [Condition])?
}

Action ::= "SELECT" | "REJECT" | "NEXT"

ReturnSpecification ::= {
  (nodeRef String)?,
  (property [PropertySpecification])?
}

PropertySpecification ::= {
  iri String,
  (return ReturnSpecification)?
}
```

---

## Appendix: Common IRIs

### Entity Types

- Patient: `http://endhealth.info/im#Patient`
- Concept: `http://endhealth.info/im#Concept`
- EpisodeOfCare: `http://endhealth.info/im#EpisodeOfCare`
- ClinicalEntry: `http://endhealth.info/im#ClinicalEntry`

### Relationships

- episodeOfCare: `http://endhealth.info/im#episodeOfCare`
- clinicalEntry: `http://endhealth.info/im#clinicalEntry`
- concept: `http://endhealth.info/im#concept`

### Standard Properties

- label: `http://www.w3.org/2000/01/rdf-schema#label`
- type: `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`
- code: `http://endhealth.info/im#code`
- effectiveDate: `http://endhealth.info/im#effectiveDate`
- gmsPatientType: `http://endhealth.info/im#gmsPatientType`

---

## Conclusion

IMQuery provides a powerful, flexible language for expressing complex clinical queries in a structured, machine-readable format. Its JSON-based syntax allows for easy parsing and transformation into other query languages (such as SQL) while maintaining semantic clarity and clinical accuracy.