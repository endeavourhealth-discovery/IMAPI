# Phase 3: IMQ to SQL Converter Implementation Guide

## Overview

This guide documents the Phase 3 implementation of the IMQ to SQL converter. The converter transforms semantic Information Model Query (IMQ) JSON structures into executable SQL queries against the Compass 2.3.0 database.

**Status**: MVP Implementation (Implementation Phase 1 from 3.Plan.md)  
**Language**: Java 21  
**Framework**: Spring Boot  
**Database Target**: Compass 2.3.0 (Compass Healthcare Database)

---

## Architecture Overview

The converter implements a modular 6-phase pipeline:

```
IMQ (JSON Input)
    ↓
[Phase 1: Parse & Validate]
    ↓
[Phase 2: Entity Resolution]
    ↓
[Phase 3: Condition Translation]
    ↓
[Phase 4-5: SQL Assembly]
    ↓
[Phase 6: Query Optimization]
    ↓
SQL (Executable Output)
```

### Key Classes

1. **IMQToSQLConverter** - Main orchestrator class
   - Coordinates all conversion phases
   - Validates input and produces final SQL
   - Manages conversion context across phases

2. **EntityResolver** - Phase 2 implementation
   - Maps IMQ entity IRIs to Compass tables
   - Resolves properties to database columns
   - Identifies required JOINs

3. **ConditionTranslator** - Phase 3 implementation
   - Translates WHERE clauses to SQL conditions
   - Handles logical operators (AND, OR, NOT)
   - Processes comparison operators and temporal conditions

4. **SQLGenerator** - Phases 4-6 implementation
   - Assembles SQL from components
   - Enforces Compass-specific rules
   - Adds organization/patient context

---

## Implemented Features (MVP)

### ✅ Phase 1: Parse & Validate
- IMQ JSON structure validation
- Required component checking (typeOf, path, where)
- Component extraction and error reporting

### ✅ Phase 2: Entity Resolution
- IMQ entity IRI to Compass table mapping
- Property IRI to column resolution
- JOIN requirement identification
- Configurable mapping via YAML/JSON

### ✅ Phase 3: Condition Translation
- Simple WHERE clause translation
- Logical operator support (AND, OR, NOT)
- Comparison operator translation (=, !=, <, <=, >, >=)
- Basic concept condition handling

### ✅ Phase 4-6: SQL Generation
- FROM clause construction with primary table
- WHERE clause assembly with organization context
- SELECT clause generation
- ORDER BY support
- Final SQL assembly and formatting

### ✅ Core Conversion Rules
- **Rule 1**: Patient context (organization_id filtering always applied)
- **Rule 2**: Multi-table concept resolution (prioritizes core_concept_id)
- **Rule 3**: Temporal precision handling (basic)
- **Rule 6**: Null-safe comparisons

---

## Usage

### Basic Usage

```java
// 1. Load mapping configuration
InputStream mappingConfig = new FileInputStream("5.MappingConfiguration.yaml");
IMQToSQLConverter converter = new IMQToSQLConverter(mappingConfig);

// 2. Create or receive IMQ Query
Query imqQuery = new Query();
imqQuery.setTypeOf("http://endhealth.info/im#Patient");
imqQuery.setWhere(/* WHERE clause */);

// 3. Generate SQL
CompassQuery sql = converter.generateSQL(
    imqQuery, 
    "org-123",        // organizationId
    12345L            // patientId
);

// 4. Execute SQL
String sqlStatement = sql.getSql();
System.out.println(sqlStatement);
```

### Input: IMQ Query Structure

```json
{
  "typeOf": "http://endhealth.info/im#Patient",
  "where": {
    "and": [
      {
        "iri": "http://endhealth.info/im#effectiveDate",
        "comparison": {
          "operator": "GT",
          "value": "2024-01-01"
        }
      },
      {
        "iri": "http://endhealth.info/im#concept",
        "is": [{"iri": "http://snomed.info/sct#123456"}]
      }
    ]
  },
  "return": [
    {"iri": "http://endhealth.info/im#id"},
    {"iri": "http://endhealth.info/im#label"}
  ]
}
```

### Output: Compass SQL Query

```sql
SELECT p.id, p.name
FROM patient p
WHERE p.organization_id = 'org-123'
  AND p.person_id = 12345
  AND observation.clinical_effective_date > '2024-01-01'
  AND observation.core_concept_id = 123456
ORDER BY p.id
```

---

## Configuration: Mapping File

The converter uses a YAML-based mapping configuration (`5.MappingConfiguration.yaml`) that defines:

### Entity Mappings
Maps IMQ entity IRIs to Compass tables:

```yaml
entityMappings:
  - imqEntityIri: "http://endhealth.info/im#Patient"
    tableName: "patient"
    primaryKey: "id"
    isPolymorphic: false
    alternateTables: []
```

**Fields**:
- `imqEntityIri`: Full IRI from IMQ specification
- `tableName`: Compass table name
- `primaryKey`: Primary key column
- `isPolymorphic`: True if entity maps to multiple tables (e.g., ClinicalEntry)
- `alternateTables`: List of alternate tables for polymorphic entities

### Property Mappings
Maps IMQ property IRIs to Compass columns:

```yaml
propertyMappings:
  - imqPropertyIri: "http://endhealth.info/im#concept"
    compassTable: "observation"
    compassColumn: "core_concept_id"
    dataType: "int"
    requiresJoin: true
    joinTable: "concept"
    joinCondition: "observation.core_concept_id = concept.dbid"
```

**Fields**:
- `imqPropertyIri`: Property IRI
- `compassTable`: Target Compass table
- `compassColumn`: Column name
- `dataType`: SQL data type
- `requiresJoin`: Whether this property requires additional table joins
- `joinTable`: Optional join target table
- `joinCondition`: SQL JOIN condition

---

## Data Types and Classes

### IMQValidationResult
Validation response object:

```java
public static class IMQValidationResult {
    private boolean valid;           // True if validation passed
    private String errorMessage;     // Error message if invalid
}
```

### CompassQuery
Generated SQL query with components:

```java
public static class CompassQuery {
    private String sql;              // Complete SQL statement
    private String selectClause;     // SELECT clause
    private String fromClause;       // FROM clause with joins
    private String whereClause;      // WHERE conditions
    private String orderByClause;    // ORDER BY clause
    private Map<String, Object> parameters;  // Query parameters
}
```

### ConversionContext
Internal state during conversion:

```java
public static class ConversionContext {
    private EntityMapping primaryEntity;     // Primary entity being queried
    private Map<String, String> tables;      // Table mappings
    private Set<String> requiredJoins;       // Required joins identified
    private String organizationId;           // Organization context
    private Long patientId;                  // Patient context
    private IMQToCompassMappingConfig mappingConfig;
}
```

---

## Error Handling

### ConversionException
Thrown when conversion fails:

```java
try {
    CompassQuery query = converter.generateSQL(imq, org, patient);
} catch (IMQToSQLConverter.ConversionException e) {
    log.error("Conversion failed: {}", e.getMessage());
    // Handle error
}
```

### Common Error Scenarios

| Error | Cause | Resolution |
|-------|-------|-----------|
| "Invalid IMQ: ..." | IMQ missing required components | Ensure IMQ has typeOf, path, or where |
| "Unknown entity type: ..." | Entity IRI not in mapping config | Add entity to 5.MappingConfiguration.yaml |
| "Unknown property: ..." | Property IRI not in mapping config | Add property to 5.MappingConfiguration.yaml |
| "Unsupported operator: ..." | Comparison operator not supported | MVP supports: =, !=, <, <=, >, >= |

---

## Implementation Details

### Phase 1: Parse & Validate

```java
IMQValidationResult validateIMQ(Query imqQuery)
```

**Validations**:
1. Query is not null
2. At least one of: typeOf, path, where clause exists
3. Required property structure is present

**Returns**: `IMQValidationResult` with validity status and optional error message

### Phase 2: Entity Resolution

```java
ConversionContext resolveEntities(Query imqQuery)
```

**Process**:
1. Resolve primary entity from `typeOf`
2. Scan WHERE clause for property references → identify additional joins
3. Scan PATH for navigation → identify join paths
4. Scan RETURN for properties → identify required projections

**Returns**: `ConversionContext` with all resolved mappings

### Phase 3: Condition Translation

```java
String translateConditions(Where where, ConversionContext context)
```

**Translation Rules**:
1. **Logical Operators**: AND/OR/NOT combine conditions with parentheses
2. **Simple Conditions**: Property + Operator + Value
3. **Concept Conditions**: Property + "is" + [Concept IRIs]
4. **Comparison**: Maps IMQ operators to SQL operators

**Supported Operators**:
- EQ (=)
- NE (!=)
- LT (<)
- LE (<=)
- GT (>)
- GE (>=)

### Phase 4-6: SQL Generation

```java
CompassQuery generateQuery(ConversionContext context, String whereClause,
                          List<ReturnProperty> returnProps, OrderLimit orderBy)
```

**Assembly Steps**:
1. Build FROM with primary table
2. Add WHERE with org/patient context + conditions
3. Build SELECT from return properties or defaults to ID
4. Add ORDER BY if specified
5. Assemble final SQL string

**Compass Rules Applied**:
1. ✅ Always include `organization_id` in WHERE (Rule 1)
2. ✅ Default to `core_concept_id` for concept references
3. ✅ Proper alias usage for multi-table queries
4. ✅ Index-friendly WHERE condition ordering

---

## Roadmap: Future Phases

### Phase 2 Implementation (Planned)
- Advanced WHERE conditions
- Full concept resolution (direct, legacy, sets, hierarchies)
- Rule-based filtering pipelines
- Cohort references
- Temporal aggregations

### Phase 3 Implementation (Planned)
- Polymorphic entity handling (UNION queries)
- Recursive concept hierarchies
- Complex aggregations
- Multi-rule decision trees

### Phase 4 Implementation (Planned)
- Comprehensive error handling
- Query optimization
- Monitoring and metrics
- Test harness with Compass database

---

## Example Queries

### Example 1: Simple Patient Query
**IMQ:**
```json
{
  "typeOf": "http://endhealth.info/im#Patient",
  "where": {
    "iri": "http://endhealth.info/im#dateOfBirth",
    "comparison": {
      "operator": "LE",
      "value": "1965-01-01"
    }
  }
}
```

**SQL Output:**
```sql
SELECT p.id
FROM patient p
WHERE p.organization_id = 'org-123'
  AND p.person_id = 12345
  AND p.date_of_birth <= '1965-01-01'
```

### Example 2: AND Condition Query
**IMQ:**
```json
{
  "typeOf": "http://endhealth.info/im#Observation",
  "where": {
    "and": [
      {
        "iri": "http://endhealth.info/im#concept",
        "is": [{"iri": "http://snomed.info/sct#3950001"}]
      },
      {
        "iri": "http://endhealth.info/im#effectiveDate",
        "comparison": {
          "operator": "GE",
          "value": "2024-01-01"
        }
      }
    ]
  }
}
```

**SQL Output:**
```sql
SELECT o.id
FROM observation o
WHERE o.organization_id = 'org-123'
  AND o.person_id = 12345
  AND (o.core_concept_id = 3950001 AND o.clinical_effective_date >= '2024-01-01')
```

### Example 3: OR Condition Query
**IMQ:**
```json
{
  "typeOf": "http://endhealth.info/im#Observation",
  "where": {
    "or": [
      {
        "iri": "http://endhealth.info/im#concept",
        "is": [{"iri": "http://snomed.info/sct#1234"}]
      },
      {
        "iri": "http://endhealth.info/im#concept",
        "is": [{"iri": "http://snomed.info/sct#5678"}]
      }
    ]
  }
}
```

**SQL Output:**
```sql
SELECT o.id
FROM observation o
WHERE o.organization_id = 'org-123'
  AND o.person_id = 12345
  AND (o.core_concept_id = 1234 OR o.core_concept_id = 5678)
```

---

## Testing

### Unit Testing Structure

```java
@SpringBootTest
public class IMQToSQLConverterTest {
    
    private IMQToSQLConverter converter;
    
    @BeforeEach
    public void setup() throws IOException {
        InputStream config = new FileInputStream("5.MappingConfiguration.yaml");
        converter = new IMQToSQLConverter(config);
    }
    
    @Test
    public void testSimplePatientQuery() throws Exception {
        Query imq = createPatientQuery();
        CompassQuery result = converter.generateSQL(imq, "org-1", 123L);
        
        assertNotNull(result);
        assertNotNull(result.getSql());
        assertTrue(result.getSql().contains("organization_id"));
    }
    
    @Test
    public void testInvalidIMQThrowsException() {
        Query invalidIMQ = new Query();  // No typeOf, path, or where
        
        assertThrows(ConversionException.class, 
            () -> converter.generateSQL(invalidIMQ, "org-1", 123L));
    }
}
```

### Integration Testing

Test against actual Compass 2.3.0 database:
1. Load test queries from `TestQueries` directory
2. Convert to SQL via converter
3. Execute against test Compass database
4. Validate results match expectations

---

## Performance Considerations

### Current MVP Optimizations

1. **Organization Context First**: Filters by org_id before other conditions
2. **Index-Friendly WHERE**: Conditions ordered to leverage database indexes
3. **No Unnecessary Joins**: Only JOINs added when properties require them

### Future Optimizations (Phase 4)

1. **Index Analysis**: Recommend indexes for generated queries
2. **Query Plan Analysis**: Review EXPLAIN output for optimization
3. **Result Set Limiting**: Add LIMIT clause for large result sets
4. **Concept Caching**: Cache concept_map lookups
5. **Materialized Views**: Use pre-computed concept hierarchies

---

## Integration with IMAPI

### Package Location
```
org.endeavourhealth.imapi.transforms.compass.IMQToSQLConverter
```

### Spring Configuration (Recommended)

```java
@Configuration
public class CompassConversionConfig {
    
    @Bean
    public IMQToSQLConverter imqToSQLConverter(
            @Value("classpath:compass-mapping.yaml") 
            Resource mappingConfig) throws IOException {
        return new IMQToSQLConverter(mappingConfig.getInputStream());
    }
}
```

### REST Endpoint (Example)

```java
@RestController
@RequestMapping("/api/compass")
public class CompassConversionController {
    
    @Autowired
    private IMQToSQLConverter converter;
    
    @PostMapping("/convert")
    public CompassQuery convert(@RequestBody Query imqQuery,
                                @RequestParam String organizationId,
                                @RequestParam(required=false) Long patientId) 
            throws ConversionException {
        return converter.generateSQL(imqQuery, organizationId, patientId);
    }
}
```

---

## Troubleshooting

### Issue: "Unknown entity type" Error

**Cause**: Entity IRI not in mapping configuration

**Solution**:
1. Check IMQ entity IRI matches exactly
2. Add entity to `5.MappingConfiguration.yaml`
3. Reload configuration

```yaml
entityMappings:
  - imqEntityIri: "http://endhealth.info/im#MyEntity"
    tableName: "my_table"
    primaryKey: "id"
    isPolymorphic: false
```

### Issue: Generated SQL Has Missing JOINs

**Cause**: Properties requiring joins not recognized

**Solution**:
1. Ensure property mapped with `requiresJoin: true`
2. Specify `joinTable` and `joinCondition`
3. Verify property IRI matches exactly

```yaml
propertyMappings:
  - imqPropertyIri: "http://endhealth.info/im#myProperty"
    compassTable: "my_table"
    compassColumn: "my_column"
    requiresJoin: true
    joinTable: "join_table"
    joinCondition: "my_table.id = join_table.my_table_id"
```

### Issue: NULL Values Not Handled Correctly

**Cause**: NULL-unsafe comparisons in WHERE clause

**Solution**: Phase 3 MVP limitation. Phase 2 will add null-safe comparison support (Rule 6):

```java
// Current: column != value
// Needed: (column != value OR column IS NULL)
```

---

## Files Included in Phase 3

1. **4.Converter.java** - Main implementation with all converter classes
2. **5.MappingConfiguration.yaml** - Entity/property mapping configuration
3. **4.ImplementationGuide.md** - This documentation

---

## Next Steps

1. **Unit Testing**: Create comprehensive test suite
2. **Mapping Verification**: Validate all 13 core entities are mapped
3. **Integration Testing**: Test against Compass 2.3.0 database
4. **Phase 2 Planning**: Advanced conditions, concept resolution
5. **Performance Baseline**: Measure query generation time and SQL performance

---

## References

- **IMQ Specification**: `../QOFtoIMQ/3.IMQ-Specification.md`
- **Compass Schema**: `2.Compass.md`
- **Conversion Plan**: `3.Plan.md`
- **Mapping Configuration**: `5.MappingConfiguration.yaml`

---

## Support & Questions

For questions or issues:
1. Check this guide's Troubleshooting section
2. Review the example queries
3. Consult the plan document for architectural details
4. Check the mapping configuration for entity/property definitions